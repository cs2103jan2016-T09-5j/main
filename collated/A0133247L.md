# A0133247L
###### \logic\AddCommand.java
``` java
/**
 * The AddCommand class handles all user commands with "add" as the first
 * keyword and processes ParsedInput to generate Todo objects and adds them into
 * memory.
 */

public class AddCommand extends Command {

	/**
	 * Creates an AddCommand object.
	 * 
	 * @param input
	 *            the ParsedInput object containing the parameters.
	 * @param memory
	 *            the memory containing the Todos to which the changes should be
	 *            committed.
	 */
	public AddCommand(ParsedInput input, Memory memory) {
		super(input, memory);
	}

	/**
	 * It takes in a ParsedInput object and generates a Todo object with respect
	 * to the ParsedInput object. The Todo object can be a floating task,
	 * deadline or event.
	 * 
	 * It returns a Signal object to indicate success or failure (if exception
	 * is thrown).
	 * 
	 * @return It returns a Signal object to indicate success or failure.
	 */
	@Override
	public Signal execute() {
		// Check for empty string params
		if (input.containsEmptyParams()) {
			return new Signal(Signal.GENERIC_EMPTY_PARAM, false);
		}

		String todoName = keyParamPairs.get(0).getParam();
		//keyParamPair.size() should be 1, and maximum of dateTimes.size() should be 2
		int numberOfParams = keyParamPairs.size() + dateTimes.size();
		// Check if Todo to be created is a recurring task
		// Recurring Deadline

		if (input.isRecurring()) {
			// Check for valid number of keywords
			if (numberOfParams > 3) {
				return new Signal(Signal.ADD_INVALID_PARAMS, false);
			}

			RecurringTodoRule rule;

			// If recurrence rule has a limit
			if (input.hasLimit()) {
				rule = new RecurringTodoRule(memory.obtainFreshRecurringId(),
						todoName, dateTimes, input.getPeriod(),
						input.getLimit());
				memory.add(rule);
			}
			// If recurrence rule has no limit
			else {
				rule = new RecurringTodoRule(memory.obtainFreshRecurringId(),
						todoName, dateTimes, input.getPeriod());
			}
			memory.add(rule);
			memory.saveToFile();
			return new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
					rule.toString()), true);

		}
		// Not recurring task
		else {
			// Check for valid number of keywords
			
			if (numberOfParams > 3) {
				
				return new Signal(Signal.ADD_INVALID_PARAMS, false);
			}

			int numberOfDates = dateTimes.size();
			Collection<Todo> listOnSameDay;
			ClashDetector eventOverlapDetector;
			
			switch (numberOfDates) {
			// No dates = floating task
			case 0:
				Todo floatingTask = new Todo(memory.obtainFreshId(), todoName);
				memory.userAdd(floatingTask);
				memory.saveToFile();
				return new Signal(String.format(
						Signal.ADD_SUCCESS_SIGNAL_FORMAT, floatingTask), true);
			// 1 date = deadline
			case 1:
				Todo timedTodo = new Todo(memory.obtainFreshId(), todoName,
						dateTimes);
				DateTime selectedDate = DateTime.now();
				if(timedTodo.endTime.isBefore(selectedDate)){
					return new Signal(Signal.ADD_PASTDATE_ERROR, true);
				}
				//ClashDetector object warns user of an impending time overlap
				listOnSameDay = SearchCommand.getTodosOfSameDay(Keywords.DAY, 
						timedTodo.endTime, memory);
				eventOverlapDetector = new ClashDetector(listOnSameDay, timedTodo);
				if(eventOverlapDetector.verifyTodoClash()) {
					return new Signal(Signal.CLASH_USER_VOID_TASK, true);
				}
				
				memory.userAdd(timedTodo);
				memory.saveToFile();
				return new Signal(String.format(
						Signal.ADD_SUCCESS_SIGNAL_FORMAT, timedTodo), true);
			// 2 dates = event
			case 2:
				timedTodo = new Todo(memory.obtainFreshId(), todoName,
						dateTimes);
				DateTime selectedDate1 = DateTime.now();
				if(timedTodo.endTime.isBefore(selectedDate1)){
					return new Signal(Signal.ADD_PASTDATE_ERROR, true);
				}
				//ClashDetector object warns user of an impending time overlap
				listOnSameDay = SearchCommand.getTodosOfSameDay(Keywords.DAY, 
						timedTodo.endTime, memory);
				eventOverlapDetector = new ClashDetector(listOnSameDay, timedTodo);
				if(eventOverlapDetector.verifyTodoClash()) {
					return new Signal(Signal.CLASH_USER_VOID_TASK, true);
				}
				
				// Start-time is after end-time
				if (dateTimes.get(0).isAfter(dateTimes.get(1))) {
					memory.saveToFile();
					return new Signal(Signal.ADD_END_BEFORE_START_ERROR, false);
				
				// Valid dates
				} else {
					memory.userAdd(timedTodo);
					memory.saveToFile();
					return new Signal(String.format(
							Signal.ADD_SUCCESS_SIGNAL_FORMAT, timedTodo), true);
				}
			}
			// Should not be reached
			memory.saveToFile();
			return new Signal(Signal.ADD_UNKNOWN_ERROR, false);
		}
	}
}
```
###### \logic\DisplayCategory.java
``` java
/**
 * The DisplayCategory Class is used to sort out display tasks for GUI 5
 * categories. Today , Tomorrow, Somedays, Upcoming and lastly, All tasks
 * 
 * This class is with DisplayCommand class (logic package) and Controller class
 * (userinterface package)
 */

public class DisplayCategory {

	/**
	 * ArrayList<String[]> sorted in to 5 categories: Today, Tomorrow, Someday,
	 * Upcoming, Command
	 * 
	 */
	private static ArrayList<String[]> todayArrListForGUI = new ArrayList<String[]>();
	private static ArrayList<String[]> tmrArrListForGUI = new ArrayList<String[]>();
	private static ArrayList<String[]> somedaysArrListForGUI = new ArrayList<String[]>();
	private static ArrayList<String[]> upcomingArrListForGUI = new ArrayList<String[]>();
	private static ArrayList<String[]> allTasksArrListForGUI = new ArrayList<String[]>();
	private static DateFormat dateFormat = new SimpleDateFormat("EEE dd MMM yyyy");

	/**
	 * For the Today's date display on the top left corner
	 */
	public static String getTodayDate() {
		Calendar calendar = Calendar.getInstance();
		String todayAsString = dateFormat.format(calendar.getTime());
		return todayAsString;
	}

	private static String getTmrDate() {
		Calendar calendar = Calendar.getInstance();
		calendar.add(Calendar.DAY_OF_YEAR, 1);
		String tmrAsString = dateFormat.format(calendar.getTime());
		return tmrAsString;
	}

	/**
	 * For Controller class in userinterface package to get today's ArrayList
	 * for different categories
	 */
	public static ArrayList<String[]> getTodayArrListForGUI() {
		sortTodayList();
		return todayArrListForGUI;
	}
	
	/**
	 * For Controller class in userinterface package to get tomorrow's ArrayList
	 * for different categories
	 */
	public static ArrayList<String[]> geTmrArrListForGUI() {
		sortTmrList();
		return tmrArrListForGUI;
	}

	/**
	 * For Controller class in userinterface package to get Someday's ArrayList
	 * for different categories
	 */
	public static ArrayList<String[]> getSomedaysArrListForGUI() {
		sortSomedayList();
		return somedaysArrListForGUI;
	}

	/**
	 * For Controller class in userinterface package to get upcoming's ArrayList
	 * for different categories
	 */
	public static ArrayList<String[]> getUpcommingArrListForGUI() {
		sortUpcomingList();
		return upcomingArrListForGUI;
	}

	/**
	 * For Controller class in userinterface package to get allTasks' ArrayList
	 * for different categories
	 */
	public static ArrayList<String[]> getAllTasksArrListForGUI() {
		sortAllTasksList();
		return allTasksArrListForGUI;
	}

	/**
	 * For Controller class to refresh/clear the ArrayLists
	 */
	public static void clearArrListForGUI() {
		todayArrListForGUI.clear();
		tmrArrListForGUI.clear();
		somedaysArrListForGUI.clear();
		upcomingArrListForGUI.clear();
		allTasksArrListForGUI.clear();
	}

	/**
	 * Internal logic to sort out today's ArrayList
	 * return true if the sorted list do not have sorting error and is not empty
	 * return false if the sorted list have sorting error or it is empty
	 */
	private static boolean sortTodayList() {
		String todayAsString = getTodayDate();
		ArrayList<ArrayList<String[]>> display = taskListProcessor();
		todayArrListForGUI.clear();
		
		try {
			if (!display.isEmpty()) {
				for (int i = 0; i < display.size(); i++) {
					if (!display.get(i).isEmpty()) {
						if (display.get(i).get(0)[0].equals(todayAsString)) {
							todayArrListForGUI = display.get(i);
							return true;
						}
					}
				}
			}
			return false;
		} catch (Exception e) {
			return false;
		}
	}
	
	/**
	 * Internal logic to sort out tomorrow's ArrayList
	 * return true if the sorted list do not have sorting error and is not empty
	 * return false if the sorted list have sorting error or it is empty
	 */
	private static boolean sortTmrList() {
		String tmrAsString = getTmrDate();
		ArrayList<ArrayList<String[]>> display = taskListProcessor();
		tmrArrListForGUI.clear();
		
		try {
			if (!display.isEmpty()) {
				for (int i = 0; i < display.size(); i++) {
					if (!display.get(i).isEmpty()) {
						if (display.get(i).get(0)[0].equals(tmrAsString)) {
							tmrArrListForGUI = display.get(i);
							return true;
						}
					}
				}
			}
			return false;
		} catch (Exception e) {
			return false;
		}
	}
	
	/**
	 * Internal logic to sort out someday's ArrayList
	 * return true if the sorted list do not have sorting error and is not empty
	 * return false if the sorted list have sorting error or it is empty
	 */
	private static boolean sortSomedayList() {
		ArrayList<ArrayList<String[]>> display = taskListProcessor();
		somedaysArrListForGUI.clear();
		
		try {
			if (!display.isEmpty()) {
				for (int i = 0; i < display.size(); i++) {
					if (!display.get(i).isEmpty()) {
						if (display.get(i).get(0)[0].equals("Anytime")) {
							somedaysArrListForGUI = display.get(i);
							return true;
						}
					}
				}
			}
			return false;
		} catch (Exception e) {
			return false;
		}
	}
	
	/**
	 * Internal logic to sort out upcoming's ArrayList
	 * return true if the sorted list do not have sorting error and is not empty
	 * return false if the sorted list have sorting error or it is empty
	 */
	private static boolean sortUpcomingList() {
		String todayAsString = getTodayDate();
		String tmrAsString = getTmrDate();
		ArrayList<ArrayList<String[]>> display = taskListProcessor();
		upcomingArrListForGUI.clear();
		
		try {
			if (!display.isEmpty()) {
				for (int i = 0; i < display.size(); i++) {
					if (!display.get(i).isEmpty()) {
						String str = display.get(i).get(1)[3];
						if (!str.equals("Anytime") && !str.equals(tmrAsString) 
								&& !str.equals(todayAsString)) {
							combineArrList(display.get(i), upcomingArrListForGUI);
						}
					}
				}
			}
			return true;
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * Internal logic to sort out allTasks's ArrayList
	 * return true if the sorted list do not have sorting error and is not empty
	 * return false if the sorted list have sorting error or it is empty
	 */
	private static boolean sortAllTasksList() {
		ArrayList<ArrayList<String[]>> display = taskListProcessor();
		allTasksArrListForGUI.clear();
		
		try {
			if (!display.isEmpty()) {
				for (int i = 0; i < display.size(); i++) {
					if (!display.get(i).isEmpty()) {
						combineArrList(display.get(i), allTasksArrListForGUI);
					}
				}
			}
			return true;
		} catch (Exception e) {
			return false;
		}
	}

	/**
	 * For sortUpcomingList and sortAllTasksList to combine all the sorted
	 * tasks. sortUpcomingList would combine date of tasks without today & tmr &
	 * anytime tasks sortAllTaskList would combine date of tasks with all the 4
	 * categories ( today & tmr & upcoming & anytime )
	 */
	private static void combineArrList(ArrayList<String[]> displayAL, ArrayList<String[]> upComingAL) {
		if (!displayAL.isEmpty()) {
			for (int i = 1; i < displayAL.size(); i++) {
				upComingAL.add(displayAL.get(i));
			}
		}
	}

	/****************PROCESS RAW DATA FROM DISPLAYCOMMAND **********/
	/**
	 * Use to process the raw tasks from the DisplayCommand class into
	 * ArrayList<ArrayList<String[]>> which is (1)ArrayList of different date
	 * and (2)ArrayList of tasks for specific date (3)String[] of index[0] is
	 * the ID of the task, index[1] is the name of the task, index[2] is the
	 * time to time taken for the task, index[3] is the date of the task
	 */
	private static ArrayList<ArrayList<String[]>> taskListProcessor() {
		ArrayList<ArrayList<String[]>> list = new ArrayList<ArrayList<String[]>>();
		
		try {
			String[] splitString = DisplayCommand.getArrListForGUI().get(0).split("\\r?\\n");
			ArrayList<String[]> currList = null;
			String currDate = "";
			
			for (int i = 0; i < splitString.length; i++) {
				
				if (splitString[i].length() == 0 
						|| splitString[i].equals(System.getProperty("line.separator"))) {
					continue;
				}
				
				if (splitString[i].contains("..")) {
					
					if (currList != null && !currList.isEmpty()) {
						list.add(currList);
					}
					currList = new ArrayList<String[]>();
					String dateString = splitString[i];
					dateString = dateString.replace("...", "");
					dateString = dateString.replace("..", "");
					dateString = dateString.replace(".", "");
					currDate = dateString;
					String[] inputDate = { dateString, "", "" };
					currList.add(inputDate);
				} else {
					splitString[i].trim();
					String[] split = splitString[i].split("~");
					String[] splitTask = new String[4];
					
					for (int j = 0; j < 3; j++) {
						splitTask[j] = split[j];
						splitTask[j] = splitTask[j].trim();
					}
					splitTask[3] = currDate;
					currList.add(splitTask);
				}
			}
			list.add(currList);
			return list;
		} catch (Exception e) {
			return list;
		}

	}
}
```
###### \logic\DisplayCommand.java
``` java
public class DisplayCommand extends Command {

    private static Logger logger = LoggerFactory
            .getLogger(DisplayCommand.class);

    private static final boolean LOGGING = false;

	// Parameters allowed for display command
    private static final String PARAM_ALL_1 = "all";
    private static final String PARAM_ALL_2 = "a";
    private static final String PARAM_COMPLETE_1 = "completed";
    private static final String PARAM_COMPLETE_2 = "complete";
    private static final String PARAM_COMPLETE_3 = "c";
    private static final String PARAM_RULE = "rule";

	// Signals for whether to display pending or completed todos
	private static final int showPending = 0;
	private static final int showCompleted = 1;
	private static final int showAll = 2;
	
    private static final String MESSAGE_RULES = "";

	// Max length for the title of todo to be displayed
    private static final int MAX_CHAR = 30;
    private static final int TOTAL_LENGTH = 20;

    // Decoration for date section heading
    private static final String DATE_DECO = ".";

    // Empty field text
    private static final String EMPTY_FIELD = "NIL";

    // String formats
    private static final String eventFormat = " %1$s ~ %2$s ~ %3$s - %4$s";
    private static final String deadLineFormat = " %1$s ~ %2$s ~ %3$s";
    private static final String floatingFormat = " %1$s ~ %2$s ~ %3$s";

    private static DateTime inOneDay = new DateTime().plusDays(1);

	private static final DateTimeFormatter DateFormatter = DateTimeFormat
            .forPattern("EEE dd MMM yyyy");
	private static final DateTimeFormatter TimeFormatter = DateTimeFormat
			.forPattern("HH:mm");

    private static final String RELATIVE_PERIOD_PREFIX = " in ";
    private static final String FLOATING_TASK_HEADING = "Anytime";
    
    // Relative timing format
    private static PeriodFormatter formatter = new PeriodFormatterBuilder()
            .appendHours().appendSuffix("h ")
            .printZeroNever().appendMinutes().appendSuffix("min ")
            .printZeroNever().toFormatter();
    //For GUI display
    private static  ArrayList<String> arrListForGUI = new ArrayList<String> ();
    
    /**
     * Creates a DisplayCommand object.
     * 
     * @param input the ParsedInput object containing the parameters.
     * @param memory the memory containing the Todos to which the changes should
     *            be committed.
     */
    public DisplayCommand(ParsedInput input, Memory memory) {
    	super(input, memory);
    }
    protected static ArrayList<String> getArrListForGUI(){
    	return arrListForGUI;
    }
    public static void clearArrListForGUI(){
    	arrListForGUI.clear();
    }

    @Override
	public Signal execute() {
		String displayString;
		Collection<Todo> todos = memory.getAllTodos();
		if (todos.size() == 0) {
            return new Signal(Signal.DISPLAY_EMPTY_TODO_SIGNAL, true);
		}

        // Check that display command only have one key param pair
        if (keyParamPairs.size() > 1) {
            String param = keyParamPairs.get(1).getParam();
            return new Signal(
                    String.format(Signal.DISPLAY_INVALID_PARAM, param), false);
        }

		String param = keyParamPairs.get(0).getParam();
        if (param.isEmpty()) {
            // By default we show pending tasks, in chronological order
            displayDefault();
        } else if (param.equals(PARAM_COMPLETE_1) || param.equals(PARAM_COMPLETE_2)
				|| param.equals(PARAM_COMPLETE_3)) {
            displayString = getDisplayChrono(showCompleted);
            arrListForGUI.add(displayString);
		} else if (param.equals(PARAM_ALL_1) || param.equals(PARAM_ALL_2)) {
            displayString = getDisplayChrono(showAll);
            arrListForGUI.add(displayString);
        } else if (param.equals(PARAM_RULE)) {
            Collection<RecurringTodoRule> rules = memory.getAllRules();
            // Display message if there are no rules
            if (rules.isEmpty()) {
                return new Signal(Signal.DISPLAY_EMPTY_RULE_SIGNAL, true);
            }
            displayString = getDisplayForRules(rules);
        } else {
            // Try to parse the param as the id of a specific todo to show
            // the detail of the todo

            try {
                int id = Integer.parseInt(param);
                Todo todo = memory.getTodo(id);
                displayString = todo.toString();
                arrListForGUI.add(displayString);
                System.out.println(displayString);
            } catch (NullTodoException e) {
                return new Signal(String.format(Signal.DISPLAY_ID_NOT_FOUND,
                        param), false);
            } catch (NumberFormatException e) {
                return new Signal(String.format(Signal.DISPLAY_INVALID_PARAM,
                        param), false);
            }

        }
        return new Signal(Signal.DISPLAY_SUCCESS_SIGNAL, true);
	}

    private String getDisplayForRules(Collection<RecurringTodoRule> rules) {
        StringBuilder sBuilder = new StringBuilder();
        sBuilder.append(MESSAGE_RULES + System.lineSeparator());

        Iterator<RecurringTodoRule> iterator = rules.iterator();
        while (iterator.hasNext()) {
            sBuilder.append(System.lineSeparator());
            RecurringTodoRule recurringTodoRule = (RecurringTodoRule) iterator
                    .next();
            sBuilder.append(recurringTodoRule.getDisplayString());

        }
        return sBuilder.toString();
    }

    public void displayDefault() {
        displayDefault(memory);
    }

    public static void displayDefault(Memory memory) {
        String displayString;
        displayString = getDisplayChrono(memory, showPending);
        arrListForGUI.add(displayString);
        //System.out.println(displayString);
    }

    public static String getDisplayChrono(Memory memory, int signal) {
        Collection<Todo> todos = memory.getAllTodos();
        ArrayList<Todo> clonedTodos = cloneTodos(todos);
        // By default, we order the todos in chronological order
        Collections.sort(clonedTodos, new ChronoComparator());
        return getDisplayString(clonedTodos, signal);
    }

    public static String getDisplayChrono(ArrayList<Todo> todos, int signal) {
        ArrayList<Todo> clonedTodos = cloneTodos(todos);
        // By default, we order the todos in chronological order
        Collections.sort(clonedTodos, new ChronoComparator());
        return getDisplayString(clonedTodos, signal);
    }

    public String getDisplayChrono(int signal) {
        Collection<Todo> todos = memory.getAllTodos();
        ArrayList<Todo> clonedTodos = cloneTodos(todos);
        // By default, we order the todos in chronological order
        Collections.sort(clonedTodos, new ChronoComparator());
		return getDisplayString(clonedTodos, signal);
	}

	private static ArrayList<Todo> cloneTodos(Collection<Todo> todos) {
		ArrayList<Todo> clonedTodos = new ArrayList<Todo>(todos.size());
		for (Todo todo : todos) {
			clonedTodos.add(todo.copy());
		}
		return clonedTodos;
	}

    public static String getDisplayString(Collection<Todo> todos, int signal) {
        // Break down the events that spans across several days
        todos = breakDownLongEvents(todos);

		Iterator<Todo> iterator = todos.iterator();
		StringBuilder sBuilder = new StringBuilder();
        DateTime currentDate = new DateTime(0);

		while (iterator.hasNext()) {
			Todo todo = iterator.next();
            if (LOGGING) {
                logger.info("adding todo {} into display", todo.getName());
            }

            // Show pending, skip the completed tasks
            if (signal == showPending && todo.isDone()) {
                continue;
            }
            // Show completed, skip the pending tasks
            if (signal == showCompleted && !todo.isDone()) {
                continue;
            }
            DateTime todoDateTime = todo.getDateTime();
            currentDate = appendDateIfNew(sBuilder, currentDate, todoDateTime);
            appendTodo(sBuilder, todo);
		}
		return sBuilder.toString();
	}

    /**
     * This method handles the events that spans over a few days and break them
     * down into smaller todos within one day for display purposes
     * 
     * @param todos
     *            todos to be broken down
     * @return todos with long events broken down into shorter ones which are
     *         within a single day
     */
    private static Collection<Todo> breakDownLongEvents(Collection<Todo> todos) {
        ArrayList<Todo> shortTodos = new ArrayList<Todo>();
        for (Todo todo : todos) {
            if (todo.isEvent()
                    && !todo.isSameDayEvent()) {
                shortTodos.addAll(todo.breakIntoShortEvents());
            } else {
                shortTodos.add(todo);
            }
        }
        Collections.sort(shortTodos, new ChronoComparator());
        return shortTodos;
    }


    /**
     * Append the date if the date is a new one and has not been displayed yet
     * 
     * @param sBuilder
     * @param currentDate
     * @param todoDateTime
     * @return the updated current date
     */
    private static DateTime appendDateIfNew(StringBuilder sBuilder,
            DateTime currentDate, DateTime todoDateTime) {
        if (!dateAlreadyDisplayed(currentDate, todoDateTime)) {
            // Date not displayed yet, update currentDate and display the
            // date
            currentDate = todoDateTime;
            appendDate(sBuilder, todoDateTime);
        }
        return currentDate;
    }

    /**
     * Check if the date is already displayed
     * 
     * currentDate will be set to null for the first floating task, and a
     * heading for floating task will be displayed.
     * 
     * Subsequent floating tasks will not have the heading displayed when the
     * currentDate is null.
     * 
     * @param currentDate
     * @param dateTime
     * @return	true if date has already been displayed, false otherwise.
     */
    private static boolean dateAlreadyDisplayed(DateTime currentDate,
            DateTime dateTime) {
        if (currentDate == null) {
            // null currentDate indicates that floating task heading has
            // already been displayed, no other headings will be displayed
            return true;
        }
        if (dateTime == null) {
            // null dateTime indicates that this is a floating task
            return false;
        }
        if (isSameDay(currentDate, dateTime)) {
            return true;
        } else {
            return false;
        }
    }

    private static boolean isSameDay(DateTime date1, DateTime date2) {
        if (date1 == null || date2 == null) {
            return false;
        }
        return (date1.getDayOfYear() == date2.getDayOfYear() && date1
                .getYear() == date2.getYear());
    }

    /**
     * Append the date before the task details if the date is not already
     * appended.
     * 
     * Each date will be displayed only once for all tasks on that date.
     * 
     * Floating tasks will have a heading in place of the date.
     * 
     * @param sBuilder
     * @param todo
     */
    private static void appendDate(StringBuilder sBuilder, DateTime dateTime) {
        // Add empty spaces in front
        sBuilder.append("");
        if (dateTime == null) {
            // Floating task, add heading
            sBuilder.append(addDecoForDate(FLOATING_TASK_HEADING)
                    + System.lineSeparator());
        } else {
            sBuilder.append(addDecoForDate(formatDateForDisplay(dateTime))
                    + System.lineSeparator());
        }
    }

    private static String addDecoForDate(String s) {
        return StringUtils.center(s, TOTAL_LENGTH, DATE_DECO);
    }
    
    private static void appendTodo(StringBuilder sBuilder, Todo todo) {
		if (todo.getStartTime() != null && todo.getEndTime() != null) {
			sBuilder.append(formatEvent(todo));
		} else if (todo.getEndTime() != null) {
			sBuilder.append(formatDeadline(todo));
		} else if (todo.getStartTime() == null && todo.getEndTime() == null) {
			sBuilder.append(formatFloatingTask(todo));
		}
	}

	private static String formatFloatingTask(Todo todo) {
		String title = todo.getName();
        title = shortenTitle(title);
		String id = String.valueOf(todo.getId());
        return String.format(floatingFormat, id, title, EMPTY_FIELD)
				+ System.lineSeparator();
	}

	private static String formatDeadline(Todo todo) {
		String title = todo.getName();
        title = shortenTitle(title);
		String id = String.valueOf(todo.getId());
		DateTime endTime = todo.getEndTime();
        String endTimeString = formatTimeForDisplay(endTime);
        return String.format(deadLineFormat, id, title,
				endTimeString) + System.lineSeparator();
	}

	private static String formatEvent(Todo todo) {
		String title = todo.getName();
        title = shortenTitle(title);
		String id = String.valueOf(todo.getId());
		DateTime startTime = todo.getStartTime();
		DateTime endTime = todo.getEndTime();
        String startTimeString = formatTimeForDisplay(startTime);
        String endTimeString = formatTimeForDisplay(endTime);
        return String.format(eventFormat, id, title,
				startTimeString, endTimeString) + System.lineSeparator();
	}

	static class ChronoComparator implements Comparator<Todo> {

		@Override
		public int compare(Todo o1, Todo o2) {
			// Floating tasks with no time will be sorted in lexicographical
			// order
			if (o1.getDateTime() == null && o2.getDateTime() == null) {
				return o1.getName().compareTo(o2.getName());
			}
			// If only one todo has time, the other with no time will be sorted
			// to the back
			if (o1.getDateTime() == null) {
				return 1;
			} else if (o2.getDateTime() == null) {
				return -1;
			} else {
				// Both have time, compare directly
				return o1.getDateTime().compareTo(o2.getDateTime());
			}
		}
	}

	private static String shortenTitle(String title) {
		int maxLength = (title.length() < MAX_CHAR) ? title.length() : MAX_CHAR;
		title = title.substring(0, maxLength);
		return title;
	}

    private static String formatTimeForDisplay(DateTime time) {
        DateTime now = new DateTime();
        String periodString = "";
        if (time.isAfter(now) && time.isBefore(inOneDay)) {
            Period period = new Period(now, time);
            periodString = RELATIVE_PERIOD_PREFIX + formatter.print(period);
        }

        String timeString = TimeFormatter.print(time).concat(periodString);
        return timeString;
    }

    private static String formatDateForDisplay(DateTime time) {
        String dateString = DateFormatter.print(time);
        return dateString;
    }

    static class StringUtils {

        public static String center(String s, int size) {
            return center(s, size, " ");
        }

        public static String center(String s, int size, String pad) {
            if (pad == null)
                throw new NullPointerException("pad cannot be null");
            if (pad.length() <= 0)
                throw new IllegalArgumentException("pad cannot be empty");
            if (s == null || size <= s.length())
                return s;

            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < (size - s.length()) / 2; i++) {
                sb.append(pad);
            }
            sb.append(s);
            while (sb.length() < size) {
                sb.append(pad);
            }
            return sb.toString();
        }
    }

}
```
###### \logic\ExitCommand.java
``` java
public class ExitCommand extends Command {
	
	/**
	 * Creates an ExitCommand object.
	 * 
	 * @param input the ParsedInput object containing the parameters.
	 * @param memory the memory containing the Todos to which the changes should
	 *            be committed.
	 */
	public ExitCommand(ParsedInput input, Memory memory) {
		super(input, memory);
	}

	@Override
    public Signal execute() {
        String param = keyParamPairs.get(0).getParam();
        if (!param.isEmpty()) {
            return new Signal(Signal.EXIT_INVALLID_PARAMS, false);
        }
        
        memory.onDestroy();
        memory.saveToFile();
        return new Signal(Signal.EXIT_SUCCESS, true);
    }
}
```
###### \logic\SearchCommand.java
``` java
/**
 * The SearchCommand class handles user input with search commands.
 * 
 */
public class SearchCommand extends Command {

	private static  ArrayList<String> arrListForGUI = new ArrayList<String> ();
	private static final String REGEX_SPACE = "\\s";
		
	/**
	 * Creates a SearchCommand object.
	 * 
	 * @param input
	 *            the ParsedInput object containing the parameters.
	 * @param memory
	 *            the memory containing the Todos to which the changes should be
	 *            committed.
	 */
	public SearchCommand(ParsedInput input, Memory memory) {
		super(input, memory);
	}
	
	protected static ArrayList<String> getArrListForGUI(){
    	return arrListForGUI;
    }
	
	public static void clearArrListForGUI(){
    	arrListForGUI.clear();
    }
	
	/**
	 * Searches keywords given in parsedInput in the memory. 
	 */
	@Override
	public Signal execute() {
		ArrayList<KeyParamPair> inputList = input.getParamPairs();
		ArrayList<Todo> todos = new ArrayList<Todo>();
		KeyParamPair pair;
		Keywords typeKey;
		String param;
		List<DateTime> dateTimes = input.getDateTimes();

		// Iterates through every KeyParamPair
		for (int i = 0; i < inputList.size(); i++) {
			pair = inputList.get(i);
			typeKey = pair.getKeyword();
			param = pair.getParam();

			// assumes that if no flag input, assume that user is searching in
			// Todo name
			if (i == 0) {
				typeKey = Keywords.NAME;
			}

			// checks if param behind a flag is an empty string
			if (i != 0 && param.isEmpty()) {
				return new Signal(Signal.GENERIC_EMPTY_PARAM, false);
			}

			try {
				searchIndex(todos, typeKey, param, dateTimes);
			} catch (InvalidParamException e) {
				return new Signal(Signal.SEARCH_INVALID_PARAMS, false);
			}

		}

		// checks if resultSet is empty
		if (todos.isEmpty()) {
			return new Signal(Signal.SEARCH_EMPTY_SIGNAL, false);
		}

		// displays the list of todos that were found
		String displayString = DisplayCommand.getDisplayChrono(todos, 2);
		arrListForGUI.add(displayString);

		return new Signal(Signal.SEARCH_SUCCESS_SIGNAL, true);
	}

	/**
	 * Operation generates Collection of Todo Objects based on their ids and
	 * search date and type
	 * 
	 * @param typeKey
	 * @param searchDate
	 * @param todoIds
	 * @return Collection of Todo
	 * @throws InvalidParamException
	 */
	private Collection<Todo> getTodos(Keywords typeKey, DateTime searchDate,
			ArrayList<Integer> todoIds) throws InvalidParamException {
		if (typeKey != Keywords.NAME && searchDate == null) {
			throw new InvalidParamException(
					ExceptionMessages.INVALID_SEARCH_TYPE);
		}
		ArrayList<Todo> todos = new ArrayList<Todo>();
		Todo current;

		for (int x : todoIds) {
			try {
				current = memory.getTodo(x);
				if (current != null) {
					if (current.isEvent() && !current.isSameDayEvent()) {
						for (Todo shortTodo : current.breakIntoShortEvents()) {
							switch (typeKey) {
								case YEAR:
									if (shortTodo.getEndTime().getYear() == searchDate
											.getYear()) {
										todos.add(shortTodo);
									}
									break;
								case MONTH:
									if (shortTodo.getEndTime().getMonthOfYear() == searchDate
											.getMonthOfYear()) {
										todos.add(shortTodo);
									}
									break;
								case DAY:
									if (shortTodo.getEndTime().getDayOfWeek() == searchDate
											.getDayOfWeek()) {
										todos.add(shortTodo);
									}
									break;
								case TIME:
									if (shortTodo.getEndTime().toLocalTime()
											.equals(searchDate.toLocalTime())
											|| shortTodo
													.getStartTime()
													.toLocalTime()
													.equals(searchDate
															.toLocalTime())) {
										todos.add(shortTodo);
									}
									break;
								case DATE:
									if(shortTodo.getEndTime().toLocalDate().equals(searchDate.toLocalDate())) {
										todos.add(shortTodo);
									}
									break;
								default:
									
							}
						}

					} else {
						todos.add(current);
					}
				}
			} catch (NullTodoException e) {
				
			}
		}
		return todos;
	}

	/**
	 * Search memory for each string in param array based on the typeKey and
	 * updates the resultSet with the ids of the Todos found
	 * 
	 * @param resultSet
	 * @param key
	 * @param paramArray
	 * @throws InvalidDateException
	 * @throws InvalidParamException
	 */
	private void searchIndex(ArrayList<Todo> resultTodos, Keywords typeKey,
			String param, List<DateTime> dateTimes)
			throws InvalidParamException {
		ArrayList<Integer> todoIds;
		DateTime searchDate;
		if (typeKey == Keywords.NAME) {
			String[] paramArray = param.split(REGEX_SPACE);
			for (String searchKey : paramArray) {
				todoIds = memory.search(typeKey, searchKey);
				addUniqueTodos(resultTodos, getTodos(todoIds));
			}
		} else { // assumes if typeKey != NAME, user wants to search for
					// dateTime
			try {
				searchDate = dateTimes.remove(0);
				todoIds = memory.search(typeKey, searchDate);
				addUniqueTodos(resultTodos, getTodos(typeKey, searchDate, todoIds));
			} catch (IndexOutOfBoundsException e) {
				throw new InvalidParamException();
			}

		}

	}

	/**
	 * Adds todos into resultTodos without repetition
	 * @param resultTodos
	 * @param todos
	 */
	private void addUniqueTodos(ArrayList<Todo> resultTodos,
			Collection<Todo> todos) {
		for (Todo todo: todos) {
			if(!resultTodos.contains(todo)) {
				resultTodos.add(todo);
			}
		}
		
	}


	/**
	 * Retrieves a Collection of Todo objects based on their todoIds
	 * 
	 * @param todoIds
	 * @return Collection of Todos
	 */
	private Collection<Todo> getTodos(ArrayList<Integer> todoIds) {
		ArrayList<Todo> todos = new ArrayList<Todo>();
		Todo todo;
		for (int id : todoIds) {
			try {
				todo = memory.getTodo(id);
				todos.add(todo);
			} catch (NullTodoException e) {

			}
		}
		return todos;
	}	
	
```
###### \logic\SearchDisplay.java
``` java
/**
 * The SearchDisplay class is used to sort out search result 
 * and return the search result into an ArrayList before passing it 
 * to userinterface
 */

public class SearchDisplay{
	private static  ArrayList<String[]> searchArrListForGUI = new ArrayList<String[]> ();
		
	/**
	 * Internal logic to sort out search's ArrayList
	 * return true if the sorted list do not have sorting error and is not empty
	 * return false if the sorted list have sorting error or it is empty
	 */
	private static boolean sortSearchList() {
		ArrayList<ArrayList<String[]>> display = taskListProcessor();
		
		for(int i = 0; i < display.size(); i++) {
			combineArrList(display.get(i), searchArrListForGUI);
    	}
		 return true;
	}
	
	/**
	 * To combine all the sorted tasks 
	 */
	private static void combineArrList(ArrayList<String[]> displayAL, ArrayList<String[]> upComingAL) {
		for(int i=1 ; i < displayAL.size(); i++){
			upComingAL.add(displayAL.get(i));
	    }
	}
	
	/**
	 * For Controller class in userinterface package to get search ArrayList
	 */
	public static ArrayList<String[]> getSearchArrListForGUI() {
		sortSearchList();
		return searchArrListForGUI;
	}
	
	/**
	 * For Controller class to refresh/clear the search ArrayList
	 */
	public static void clearSearchArrListForGUI() {
		searchArrListForGUI.clear();
	}
	
	/****************PROCESS RAW DATA FROM SEARCHCOMMAND **********/
	/**
	 * Use to process the raw tasks from the DisplayCommand class into
	 * ArrayList<ArrayList<String[]>> which is (1)ArrayList of different date
	 * and (2)ArrayList of tasks for specific date (3)String[] of index[0] is
	 * the ID of the task, index[1] is the name of the task, index[2] is the
	 * time to time taken for the task, index[3] is the date of the task
	 */
	private static ArrayList<ArrayList<String[]>> taskListProcessor() {
     	ArrayList<ArrayList<String[]>> list = new ArrayList<ArrayList<String[]>> ();
     	clearSearchArrListForGUI();
     	
     	try {
     		String[] splitString = SearchCommand.getArrListForGUI().get(0).split("\\r?\\n");	
    		ArrayList<String[]> currList = null;
    		String currDate = "";
    		
    		for (int i = 0; i < splitString.length; i++) {
    			
    			if (splitString[i].length() == 0 || splitString[i].equals(System.getProperty("line.separator"))) { 
    				continue;
    		    }
    			
    			if (splitString[i].contains("..")) {
    				
    				if (currList != null && !currList.isEmpty()){
    					list.add(currList);
    				}
    				currList = new ArrayList<String[]> ();
    				String dateString = splitString[i];
    				dateString = dateString.replace("...", "");
    				dateString = dateString.replace("..", "");
    				currDate = dateString;
    				String[] inputDate = {dateString, "", ""};
    				currList.add(inputDate);
    				} else {
    					splitString[i].trim();
    					String[] split = splitString[i].split("~");
    					String[] splitTask = new String[4];
    					for (int j = 0; j < 3; j++) {
    						splitTask[j] = split[j];
    						splitTask[j] = splitTask[j].trim();
    					}
    					splitTask[3] = currDate;
    					currList.add(splitTask);
    				}
    		}
    		list.add(currList);
    		return list;
    	
     	}catch(Exception e){
    		return list;
    	}
	}
}
```
###### \logic\SignalHandler.java
``` java
/**
 * The SignalHandle Class is used as a container for the messages displayed 
 * that get from the Signal Class and links to userinterface package
 * 
 * The Controller Class in the userinterface package would access 
 * SignalHandler Class to get feedback as a string
 * which to be display on the userinterface.
 *
 */

public class SignalHandler {

    private static  ArrayList<String> arrListForGUI = new ArrayList<String> ();
        
    /**
	 * For Controller class in userinterface package to get feedback's ArrayList
	 */
    public static ArrayList<String> getArrListForGUI() {
    	return arrListForGUI;
    }
    
    /**
	 * For Controller class in userinterface package to clear feedback's ArrayList
	 */
    public static void clearArrListForGUI(){
    	arrListForGUI.clear();
    }
    
    /**
   	 * To get signal feedback and add in to the ArrayList
   	 */
    public static void printSignal(Signal signal) {
        assert (signal != null);
        String message = signal.toString();
        if (message.equals(Signal.EXIT_SUCCESS)) {
        	arrListForGUI.add( message);
            System.exit(0);
        }
        if (!message.isEmpty()) {
        	arrListForGUI.add(message);
        }
	}
}
```
###### \storage\VolatileMemory.java
``` java
/**
 * Functions as an auxiliary memory that supports the main memory by providing
 * the functionality of remembering the states of Todos and RecurringTodoRules,
 * and allows the undo and redo operation to track and restore the last modified
 * object.
 * <p>
 * The VolatileMemory object should be flushed by calling the flushStacks()
 * before the main Memory is serialized and saved so that UndoRedo states that
 * are brought out of context on the next load does not persist.
 */
public class VolatileMemory {
	private Stack<Boolean> undoIsRule;
	private Stack<Boolean> redoIsRule;
	private UndoRedoStack<Todo> todoStacks;
	private UndoRedoStack<RecurringTodoRule> ruleStacks;
	private static final int STATE_STACK_MAX_SIZE = 5;
	
	public VolatileMemory(HashMap<Integer, Todo> allTodos, IDBuffer<Todo> idBuffer, HashMap<Integer, RecurringTodoRule> recurringRules, IDBuffer<RecurringTodoRule> recurringIdBuffer) {
		this.undoIsRule = new Stack<Boolean>();
		this.redoIsRule = new Stack<Boolean>();
		this.todoStacks = new UndoRedoStack<Todo>(allTodos, idBuffer, STATE_STACK_MAX_SIZE);
		this.ruleStacks = new UndoRedoStack<RecurringTodoRule>(recurringRules, recurringIdBuffer, STATE_STACK_MAX_SIZE);
	}
	
	/**
	 * Saves the state of a Todo.
	 * 
	 * @param todo the original Todo to be saved.
	 */
	public void save(Todo todo) {
		todoStacks.save(todo);
		undoIsRule.push(false);
		flushRedoStacks();
	}
	
	/**
	 * Saves the state of a RecurringTodoRule.
	 * 
	 * @param rule the original RecurringTodoRule to be saved.
	 */
	public void save(RecurringTodoRule rule) {
		ruleStacks.save(rule);
		undoIsRule.push(true);
		flushRedoStacks();
	}

	/**
	 * Reverts the last change depending on the object type that was modified by the last command.
	 * 
	 * @throws StateUndefinedException if there are no states to revert to.
	 */
	public void undo() throws StateUndefinedException {
		RecurringTodoRule rule;
		Todo todo;
		
		try {
			boolean isRule = undoIsRule.pop();
			redoIsRule.push(isRule);
			if(isRule) {
				ruleStacks.restoreHistoryState();
			} else {
				todo = todoStacks.restoreHistoryState();
				if(todo.isRecurring() && undoIsRule.peek()) {
					rule = ruleStacks.peekHistoryState();
					if(rule.getId() == todo.getRecurringId()) {
						undo();
					}
				}
			}
		} catch (EmptyStackException e) {
			throw new StateUndefinedException(ExceptionMessages.NO_HISTORY_STATES);
		} catch (NotRecurringException e) {
			// Ignore
		}
	}
	

	/**
	 * Reverts the last reversion depending on the object type that was modified by the reversion.
	 * 
	 * @throws StateUndefinedException if there are no states to revert to.
	 */
	public void redo() throws StateUndefinedException {
		RecurringTodoRule rule;
		Todo todo;
		
		try {
			boolean isRule = redoIsRule.pop();
			undoIsRule.push(isRule);
			if (isRule) {
				rule = ruleStacks.restoreFutureState();
				if(!redoIsRule.peek()) {
					todo = todoStacks.peekFutureState();
					if(todo.isRecurring() && rule.getId() == todo.getRecurringId()) {
						redo();
					}
				}
			} else {
				todoStacks.restoreFutureState();
			}
		} catch (EmptyStackException e) {
			throw new StateUndefinedException(ExceptionMessages.NO_FUTURE_STATES);
		} catch (NotRecurringException e) {
			// Ignore
		}
	}
	
	/**
	 * Flushes both rule and todo stacks to release the IDs reserved by the Todo or RecurringTodoRule objects in the stacks.
	 */
	public void flushStacks() {
		todoStacks.flushStacks();
		ruleStacks.flushStacks();
	}
	
	/**
	 * Flushes the redo stack to release the IDs reserved by the Todo or Recurring Todo objects in the redo stacks.
	 */
	private void flushRedoStacks() {
		todoStacks.flushRedoStack();
		ruleStacks.flushRedoStack();
		redoIsRule.clear();
	}
	
}
```
###### \testcases\AddCommandTest.java
``` java
	/*
	 * Test adding of events
	 */
	@Test
	public void testEvent() {
		final DateTime baseTime = new DateTime();
		DateTime changedTime;
		String formattedDate;
		String eventCommand;
		String eventString;
		Signal addSuccess;

		/*
		 * Absolute time
		 */
		/*
		 * Test for a single-worded, lower-case event, long-format
		 */
		eventCommand = "add canoeing from 3pm to 4pm on six april";
		eventString = "Event \"canoeing\" from Wed 06 Apr 2016 at 15:00 to Wed 06 Apr 2016 at 16:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event within the same day,
		 * short format
		 */

		eventCommand = "add climb Mount Everest in Nepal from 3pm to 4pm on 12 Jun";
		eventString = "Event \"climb Mount Everest in Nepal\" from Sun 12 Jun 2016 at 15:00 to Sun 12 Jun 2016 at 16:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event straddling different
		 * days, short format
		 */

		eventCommand = "add climb Mount Everest in Nepal from 5 jun 2017 3pm to 20 jun 2017 4pm";
		eventString = "Event \"climb Mount Everest in Nepal\" from Mon 05 Jun 2017 at 15:00 to Tue 20 Jun 2017 at 16:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event straddling different
		 * days, short format
		 */

		eventCommand = "add climb Mount Everest in Nepal from 3pm on 5 jun 2017 to 4pm on 20 jun 2017";
		eventString = "Event \"climb Mount Everest in Nepal\" from Mon 05 Jun 2017 at 15:00 to Tue 20 Jun 2017 at 16:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Relative time
		 */
		/*
		 * Test for a multiple-worded, mixed-case event, within a day, relative
		 * (year)
		 */
		changedTime = baseTime.plusYears(3);
		formattedDate = formatDate(changedTime);
		eventCommand = "add travel the States from 2pm to 3pm in 3 years";
		eventString = "Event \"travel the States\" from " + formattedDate
				+ " at 14:00 to " + formattedDate + " at 15:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event, within a day, relative
		 * (year)
		 */
		changedTime = baseTime.plusYears(1);
		formattedDate = formatDate(changedTime);
		eventCommand = "add travel the States from 2pm to 3pm next year";
		eventString = "Event \"travel the States\" from " + formattedDate
				+ " at 14:00 to " + formattedDate + " at 15:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event, within a day, relative
		 * (month)
		 */
		changedTime = baseTime.plusMonths(3);
		formattedDate = formatDate(changedTime);
		eventCommand = "add visit the Dentist in 3 months from 2pm to 3pm";
		eventString = "Event \"visit the Dentist\" from " + formattedDate
				+ " at 14:00 to " + formattedDate + " at 15:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event, within a day, relative
		 * (week)
		 */
		changedTime = baseTime.plusMonths(1);
		formattedDate = formatDate(changedTime);
		eventCommand = "add visit the Dentist from 2pm to 3pm next month";
		eventString = "Event \"visit the Dentist\" from " + formattedDate
				+ " at 14:00 to " + formattedDate + " at 15:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event, within a day, relative
		 * (week)
		 */
		changedTime = baseTime.plusWeeks(1);
		formattedDate = formatDate(changedTime);
		eventCommand = "add CS2010 consultation in 1 week from 9am to 12pm";
		eventString = "Event \"CS2010 consultation\" from " + formattedDate
				+ " at 09:00 to " + formattedDate + " at 12:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event, within a day, relative
		 * (week)
		 */
		changedTime = baseTime.plusWeeks(2);
		formattedDate = formatDate(changedTime);
		eventCommand = "add CS2105 consultation in 2 weeks from 10am to 2pm";
		eventString = "Event \"CS2105 consultation\" from " + formattedDate
				+ " at 10:00 to " + formattedDate + " at 14:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event, within a day, relative
		 * (week)
		 */
		changedTime = baseTime.plusWeeks(1);
		formattedDate = formatDate(changedTime);
		eventCommand = "add CS2010 consultation in 1 week from 9am to 12pm";
		eventString = "Event \"CS2010 consultation\" from " + formattedDate
				+ " at 09:00 to " + formattedDate + " at 12:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event, within a day, relative
		 * (day)
		 */
		changedTime = baseTime.plusDays(3);
		formattedDate = formatDate(changedTime);
		eventCommand = "add CS2103T presentation in 3 days from 3pm to 4pm";
		eventString = "Event \"CS2103T presentation\" from " + formattedDate
				+ " at 15:00 to " + formattedDate + " at 16:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event, within a day, relative
		 * (day)
		 */
		changedTime = baseTime.plusDays(1);
		formattedDate = formatDate(changedTime);
		eventCommand = "add cycling at ECP from 6pm to 7pm tomorrow";
		eventString = "Event \"cycling at ECP\" from " + formattedDate
				+ " at 18:00 to " + formattedDate + " at 19:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}

		/*
		 * Test for a multiple-worded, mixed-case event within a day, relative
		 * (week)
		 */
		changedTime = baseTime.plusDays(3);
		formattedDate = formatDate(changedTime);
		eventCommand = "add CS2103T presentation in 3 days from 3pm to 4pm";
		eventString = "Event \"CS2103T presentation\" from " + formattedDate
				+ " at 15:00 to " + formattedDate + " at 16:00";
		// Mock Signal object
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT,
				eventString), true);
		try {
			assertEquals(addSuccess, logic.handleInput(eventCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
	}
	
	@Test
	public void testRecurringTasks(){
		DateTime baseTime = new DateTime();
		DateTime changedTime = baseTime.plusYears(1);
		String formattedDate = formatDate(changedTime);
		Signal addSuccess;
		String recurrenceRule;
		String recurrenceCommand;
		
		/*
		 * Test for a single-worded recurring floating task (daily), no limit
		 */
		recurrenceCommand = "add swim every day";
		recurrenceRule = "Recurrence Rule: \"swim\" every 1 day(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a single-worded recurring deadline (daily), no limit
		 */
		recurrenceCommand = "add swim by 3pm every day";
		recurrenceRule = "Recurrence Rule: \"swim\" every 1 day(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a single-worded recurring deadline (daily), no limit
		 */
		recurrenceCommand = "add swim from 4pm to 5pm every day";
		recurrenceRule = "Recurrence Rule: \"swim\" every 1 day(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a single-worded recurring deadline (daily), no limit
		 */
		recurrenceCommand = "add swim from 4pm to 5pm every day";
		recurrenceRule = "Recurrence Rule: \"swim\" every 1 day(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a single-worded recurring floating task (daily), no limit
		 */
		recurrenceCommand = "add swim every day";
		recurrenceRule = "Recurrence Rule: \"swim\" every 1 day(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a single-worded recurring deadline (daily), no limit
		 */
		recurrenceCommand = "add swim by 3pm every day";
		recurrenceRule = "Recurrence Rule: \"swim\" every 1 day(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a multiple-worded recurring deadline (monthly), no limit
		 */
		recurrenceCommand = "add submit monthly report by 2300pm every month";
		recurrenceRule = "Recurrence Rule: \"submit monthly report\" every 1 month(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a multiple-worded recurring deadline (monthly), with limit
		 */
		recurrenceCommand = "add submit monthly report by 2300pm every month until 8 Dec";
		recurrenceRule = "Recurrence Rule: \"submit monthly report\" every 1 month(s) until Thu 08 Dec 2016";
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a multiple-worded recurring deadline (yearly), no limit
		 */
		recurrenceCommand = "add celebrate New Year on 1 Jan every year";
		recurrenceRule = "Recurrence Rule: \"celebrate New Year\" every 1 year(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a single-worded recurring event (daily), no limit
		 */
		recurrenceCommand = "add swim from 4pm to 5pm every day";
		recurrenceRule = "Recurrence Rule: \"swim\" every 1 day(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a multiple-worded recurring event (daily), with limit
		 */
		recurrenceCommand = "add swim at Jurong Swimming Complex from 4pm to 5pm every day until 5 jun";
		recurrenceRule = "Recurrence Rule: \"swim at Jurong Swimming Complex\" every 1 day(s) until Sun 05 Jun 2016";
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a multiple-worded recurring event(weekly), no limit
		 */
		recurrenceCommand = "add hiking at BTH from 4pm to 5pm every week";
		recurrenceRule = "Recurrence Rule: \"hiking at BTH\" every 1 week(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a multiple-worded recurring event(weekly), with limit
		 */
		recurrenceCommand = "add hiking at BTH from 4pm to 5pm every week until 8 jun";
		recurrenceRule = "Recurrence Rule: \"hiking at BTH\" every 1 week(s) until Wed 08 Jun 2016";
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a multiple-worded recurring event(month), no limit
		 */
		recurrenceCommand = "add hiking at BTH from 4pm to 5pm every month";
		recurrenceRule = "Recurrence Rule: \"hiking at BTH\" every 1 month(s) until " + formattedDate;
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
		/*
		 * Test for a multiple-worded recurring event(month), with limit
		 */
		recurrenceCommand = "add hiking at BTH from 4pm to 5pm every month until 10 dec 2017";
		recurrenceRule = "Recurrence Rule: \"hiking at BTH\" every 1 month(s) until Sun 10 Dec 2017";
		addSuccess = new Signal(String.format(Signal.ADD_SUCCESS_SIGNAL_FORMAT, recurrenceRule), true);
		try {
			assertEquals(addSuccess, logic.handleInput(recurrenceCommand));
		} catch (InvalidRecurringException | InvalidTodoNameException | ParsingFailureException e) {
		}
		
	}

}
```
###### \testcases\DisplayCommandTest.java
``` java
public class DisplayCommandTest {

    Collection<Todo> todos;

    ClockWork logic;
    
    @After
    public void tearDown() {
        logic.deleteStorageFile();
    }

    @Before
    public void setUp() throws Exception {

        String fileDirectory = ClockWork.getStorageFileDirFromSettings();
        logic = new ClockWork(fileDirectory);
        logic.reloadMemory();

        // try {
        logic.handleInput("add floating task");

        logic.handleInput("add CS3230 deadline on 9 March 9pm");

        logic.handleInput("add CIP event from 3 March at 10am to 3 March at 12pm");

        logic.handleInput("add new year from 1 January at 10am to 1 January at 11am");

        logic.handleInput("add CS1010 deadline by 3 Feb at 10pm");

        logic.handleInput("add read floating books");

        logic.handleInput("add CS3243 project deadline by 7 March at 9am");

        logic.handleInput("add CS3333 project 2 on 7 Apr 10am");

        logic.handleInput("add meet june from malaysia from 9pm on 9 march to 10pm on 10 march");

        logic.handleInput("mark 0");

        logic.handleInput("mark 2");

        todos = ClockWork.memory.getAllTodos();
    }

    @Test
    public void testDisplayChronoPending() {
        String expected = "Showing pending todos:\n"+"ID | Name                           | "
                + "Time\n\n..Fri 01 Jan 2016...\n3  | new year                       | "
                + "10:00 - 11:00\n\n..Wed 03 Feb 2016...\n4  | CS1010 deadline                | "
                + "22:00\n\n..Mon 07 Mar 2016...\n6  | CS3243 project deadline        | "
                + "09:00\n\n..Wed 09 Mar 2016...\n1  | CS3230 deadline                | "
                + "21:00\n8  | meet june from malaysia        | "
                + "21:00 - 23:59\n\n..Thu 10 Mar 2016...\n8  | meet june from malaysia        | "
                + "00:00 - 22:00\n\n..Thu 07 Apr 2016...\n7  | CS3333 project 2               | "
                + "10:00\n\n......Anytime.......\n5  | read floating books            | NIL\n";
        assertEquals(expected, DisplayCommand.getDisplayChrono(ClockWork.memory, 0));
    }

    @Test
    public void testDisplayChronoCompleted() {
        String expected = "Showing completed todos:\nID | Name                           "
                + "| Time\n\n..Thu 03 Mar 2016...\n2  | CIP event                      "
                + "| 10:00 - 12:00\n\n......Anytime.......\n0  | floating task                  "
                + "| NIL\n";
        assertEquals(expected, DisplayCommand.getDisplayChrono(ClockWork.memory, 1));
    }

}
```
###### \testcases\MemoryTest.java
``` java
public class MemoryTest {

	private static final String TASK_1 = "Read book";
	private static final String TASK_2 = "Do laundry";
	private static final String TASK_3 = "Do homework";
	Memory memory;
	Todo todo1, todo2, todo3;

	@Before
	public void setUp() throws InvalidDateException {
		memory = new Memory();
		todo1 = new Todo(0, TASK_1);
		memory.userAdd(todo1);
		todo2 = new Todo(1, TASK_2);
		memory.userAdd(todo2);
		todo3 = new Todo(2, TASK_3);
		memory.userAdd(todo3);
	}

	@Test
	public void testAddGet() throws NullTodoException {
		assertEquals("Todo1", todo1, memory.getTodo(todo1.getId()));
		assertEquals("Todo2", todo2, memory.getTodo(todo2.getId()));
		assertEquals("Todo3", todo3, memory.getTodo(todo3.getId()));
	}

	@Test
	public void testSetterGetUndo() throws StateUndefinedException,
			NullTodoException {
		memory.getToModifyTodo(todo1.getId());
		Todo todo1Copy = todo1.copy();
		todo1.setDone(true);
		assertEquals("Todo1", todo1, memory.getTodo(todo1.getId()));
		assertEquals("Todo2", todo2, memory.getTodo(todo2.getId()));
		assertEquals("Todo3", todo3, memory.getTodo(todo3.getId()));
		memory.undo();
		assertEquals("Todo1 Undo Mark", todo1Copy, memory.getTodo(todo1.getId()));
	}

	@Test
	public void testSetterGetUndoRedo() throws StateUndefinedException,
			NullTodoException {
		memory.getToModifyTodo(todo1.getId());
		Todo todo1Copy = todo1.copy();
		todo1.setDone(true);
		Todo todo1MarkCopy = todo1.copy();
		assertEquals("Todo1", todo1, memory.getTodo(todo1.getId()));
		assertEquals("Todo2", todo2, memory.getTodo(todo2.getId()));
		assertEquals("Todo3", todo3, memory.getTodo(todo3.getId()));
		memory.undo();
		assertEquals("Todo1 Undo Mark", todo1Copy, memory.getTodo(todo1.getId()));
		memory.redo();
		assertEquals("Todo1 Redo Mark", todo1MarkCopy,
				memory.getTodo(todo1.getId()));
	}

	@Test(expected = NullTodoException.class)
	public void testRemoveUndo() throws StateUndefinedException,
			NullTodoException {
		memory.removeTodo(todo2.getId());
		assertEquals("Todo1", todo1, memory.getTodo(todo1.getId()));
		memory.getTodo(todo2.getId()); // Exception
		assertEquals("Todo3", todo3, memory.getTodo(todo3.getId()));
		memory.undo();
		assertEquals("Todo2", todo2, memory.getTodo(todo2.getId()));
	}

	@Test
	public void testRemoveUndoRedo() throws StateUndefinedException,
			NullTodoException {
		memory.removeTodo(todo2.getId());
		memory.removeTodo(todo1.getId());
		memory.undo();
		assertEquals("Todo1", todo1, memory.getTodo(todo1.getId()));
		assertEquals("Todo3", todo3, memory.getTodo(todo3.getId()));
		memory.redo();
		assertEquals("Todo3", todo3, memory.getTodo(todo3.getId()));
	}

	@Test(expected = NullTodoException.class)
	public void testAddUndo() throws StateUndefinedException, NullTodoException {
		memory.undo();
		memory.getTodo(todo3.getId()); // Exception
	}

	@Test
	public void testAddUndoRedo() throws StateUndefinedException,
			NullTodoException {
		memory.undo();
		assertEquals("Todo1", todo1, memory.getTodo(todo1.getId()));
		assertEquals("Todo2", todo2, memory.getTodo(todo2.getId()));
		memory.redo();
		assertEquals("Todo3", todo3, memory.getTodo(todo3.getId()));
	}
	/*
	 * @Test public void testExternalStorage() throws NullTodoException { String
	 * jsonString = memory.exportAsJson(); Memory importedMemory =
	 * Memory.importFromJson(jsonString); Todo[] originalArray = (Todo[])
	 * memory.getAllTodos().toArray( new Todo[0]); Todo[] importedArray =
	 * (Todo[]) importedMemory.getAllTodos().toArray( new Todo[0]);
	 * assertArrayEquals(originalArray, importedArray); }
	 */
}
```
###### \userinterface\Controller.java
``` java
/**
 * The Controller's class is a link between userinterface and logic package
 * The class would get the userinput from userinterface and pass it on to the logic package.
 * Next, the logic will pass back ArrayList for display. 
 * This controller class is also a link to the AgendaHelper by fecthing the details 
 * from memory package.       
 */

public class Controller {

	private static Logger _logger = java.util.logging.Logger.getLogger("ClockworkGUIController");
	private static String _currentUserInput;
	private static ClockWork _logic;
	
	private static ArrayList<String> _feedback = new ArrayList<String>(Arrays.asList(" ", " "));
	private static ArrayList<String[]> todayList = new ArrayList<String[]>();
	private static ArrayList<String[]> _tomorrowList = new ArrayList<String[]>();
	private static ArrayList<String[]> _upcomingList = new ArrayList<String[]>();
	private static ArrayList<String[]> _somedayList = new ArrayList<String[]>();
	private static ArrayList<String[]> _searchList = new ArrayList<String[]>();
	private static ArrayList<String[]> _powerList = new ArrayList<String[]>();
	
	/**
	 * Handle event after key is pressed
	 * 
	 * @param textField
	 *        User input to be handled
	 */
	public static void implementKeystrokeEvents(final TextField textField) {
		textField.setOnKeyPressed(new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent ke) {
				executeKeyPress(textField, ke);
			}
		});
	}
	
	/**
	 * Function handles all keyboard presses accordingly
	 * 
	 * @param textField
	 *            User input to be handled
	 * @param ke
	 *            Key that is pressed
	 */
	public static void executeKeyPress(TextField textField, KeyEvent ke) {
		if (ke.getCode().equals(KeyCode.ENTER)) {
			_currentUserInput = textField.getText();
			if ((_currentUserInput != null && !_currentUserInput.isEmpty())) {
				processEnter(_currentUserInput);
				textField.clear();
			}
		} else if (ke.getCode().equals(KeyCode.F1)) {
			// HELP SCENE
			Main.displayHelpScene();
		} else if (ke.getCode().equals(KeyCode.F2)) {
			// DISPLAY CALENDAR
			Main.displayCalendarScene();
		} else if (ke.getCode().equals(KeyCode.F3)) {
			// DISPLAY SUMMARY SCENE
			Main.setNumToday(getNumTodayItems());
			Main.setNumTomorrow(getNumTomorrowItems());
			Main.setNumUpcoming(getNumUpcomingItems());
			Main.setNumSomeday(getNumSomedayItems());
			Main.displayCategoryScene();
		} else if (ke.getCode().equals(KeyCode.DELETE)) {
			// MINIMISE
			Main.minimise();
		}
	}
	
	/**
	 * This method is used to handle the linkage between logic and GUI.
	 * userInput is collected from the TextField and passed in on to logic.
	 * 
	 * Logic would return the information generated for display: 
	 * 1. number of items in each category, 2. tasks from each category 
	 * 3. Signal feedback from the logic (error/successful)  
	 */
	public static void processEnter(String userInput) {
		_logger.log(Level.INFO, "Calling logic to process keypress.");
		
		try {	
			String[] keyword = userInput.split(" ");
			
			if (keyword[0].equalsIgnoreCase("search")) {
				resetSearchLists();
				ClockWork.ClockworkLogicMain(userInput, _logic);
				_feedback = SignalHandler.getArrListForGUI();
				_searchList = SearchDisplay.getSearchArrListForGUI();
				//DISPLAY SEARCH LIST
				Main.setSearchList(_searchList);
				Main.displaySearchScene();
		
			} else if (keyword[0].equalsIgnoreCase("add") || keyword[0].equalsIgnoreCase("delete")
					|| keyword[0].equalsIgnoreCase("mark") || keyword[0].equalsIgnoreCase("exit")
					|| keyword[0].equalsIgnoreCase("redo") || keyword[0].equalsIgnoreCase("undo")
					|| keyword[0].equalsIgnoreCase("delete") || keyword[0].equalsIgnoreCase("edit")) {
				resetAllLists();
				ClockWork.ClockworkLogicMain(userInput, _logic);
				getFiveMainLists();
				//DISPLAY ALL TASKES WITH CHANGES
				processDefaultLogicToDisplay();
			
			} else if (keyword[0].equalsIgnoreCase("display")) {
				//DISPLAY ALL TASKES
				if ( keyword.length == 1 ) {
					resetDisplayLists();
					ClockWork.ClockworkLogicMain(userInput, _logic);
					getFiveMainLists();
					processDefaultLogicToDisplay();
				} else {
					prcoessErrorLogicToDisplay(userInput);
				}
			
			} else {
				prcoessErrorLogicToDisplay(userInput);
			}		
		
		} catch (Exception ex) {
			_logger.log(Level.WARNING, "Keypress detected, but failed to process.", ex);
		}
		_logger.log(Level.INFO, "Sucessfully called logic to process keypress.");
	}
	
	/**
	 * This is a method to get the Feedback from logic package 
	 */
	public static ArrayList<String> getFeedback() {
		resetFeedbackList();
		
		if (!SignalHandler.getArrListForGUI().isEmpty() 
				&& ClashDetector.getArrListForGUI().isEmpty()) {
			_feedback = SignalHandler.getArrListForGUI();
		} else if (!ClashDetector.getArrListForGUI().isEmpty()) {
			_feedback = ClashDetector.getArrListForGUI();
		}
		return _feedback;
	}
	
	/**
	 * Function handles all keyboard presses accordingly
	 * and change to the specific scene that is pressed
	 * 
	 * @param buttom
	 *            Buttons of the 4 categories: 
	 *            1. Today
	 *            2. Tomorrow
	 *            3. Upcoming
	 *            4. Somedays
	 * @param ke
	 *            Key that is pressed
	 */
	public static void redirectScene(Button button, String sceneName) {
		button.setOnKeyPressed(new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent ke) {
				
				if (ke.getCode().equals(KeyCode.ENTER)) {
					ClockWork.ClockworkLogicMain("display", _logic);
					
					if (sceneName.equals("Today")) {
						todayList = DisplayCategory.getTodayArrListForGUI();
						Main.setTodayList(todayList);
						Main.displayTodayScene();
						Main.displayTodayScene();
					} else if (sceneName.equals("Tomorrow")) {				
						_tomorrowList = DisplayCategory.geTmrArrListForGUI();
						Main.setTomorrowList(_tomorrowList);
						Main.displayTomorrowScene();
					} else if (sceneName.equals("Upcoming")) {		
						_upcomingList = DisplayCategory.getUpcommingArrListForGUI();
						Main.setUpcomingList(_upcomingList);
						Main.displayUpcomingScene();
					} else if (sceneName.equals("Someday")) {
						_somedayList = DisplayCategory.getSomedaysArrListForGUI();
						Main.setSomedayList(_somedayList);
						Main.displaySomedayScene();
					} 
				} else if (ke.getCode().equals(KeyCode.F1)) {
					// HELP SCENE
					Main.displayHelpScene();
				} else if (ke.getCode().equals(KeyCode.F2)) {
					// DISPLAY CALENDAR
					Main.displayCalendarScene();
				} else if (ke.getCode().equals(KeyCode.DELETE)) {
					// MINIMISE
					Main.minimise();
				}
			}
		});
	}
	
	/**
	 * This method is to allow user to reset the feedback list 
	 * at initial launch, Main class
	 */
	protected static void resetFeedbackList() {
		_feedback = new ArrayList<String>();
		_feedback.add("");
		_feedback.add("");
	}
	
	/**
	 * To get the five main ArrayLists from logic package:
	 *            1. Today
	 *            2. Tomorrow
	 *            3. Upcoming
	 *            4. Somedays
	 *            5. AllTasks
	 */
	private static void getFiveMainLists() {
		todayList = DisplayCategory.getTodayArrListForGUI();
		_tomorrowList = DisplayCategory.geTmrArrListForGUI();
		_upcomingList = DisplayCategory.getUpcommingArrListForGUI();
		_somedayList = DisplayCategory.getSomedaysArrListForGUI();
		_powerList = DisplayCategory.getAllTasksArrListForGUI();
	}
	
	/**
	 * This method is a break down to process connection between userinput 
	 * and logic after key press in processEnter() method.
	 */
	private static void prcoessErrorLogicToDisplay(String userInput) {
		SignalHandler.clearArrListForGUI();
		ClashDetector.clearArrListForGUI();
		ClockWork.ClockworkLogicMain(userInput, _logic);
		processDefaultLogicToDisplay();
	}
	
	/**
	 * This method is a break down to process connection between userinput 
	 * and logic after key press in processEnter() method.
	 */
	private static void processDefaultLogicToDisplay() {
		Main.setPowerList(_powerList);
		Main.displayAllScene();
		
		Main.setNumToday(getNumTodayItems());
		Main.setNumTomorrow(getNumTomorrowItems());
		Main.setNumUpcoming(getNumUpcomingItems());
		Main.setNumSomeday(getNumSomedayItems());
	}
	
	/**
	 * Reset all the ArrayLists collected from logic output
	 */
	protected static void resetAllLists() {
		SignalHandler.clearArrListForGUI();
		DisplayCommand.clearArrListForGUI();
		SearchCommand.clearArrListForGUI();
		ClashDetector.clearArrListForGUI();
	    DisplayCategory.clearArrListForGUI();
	    SearchDisplay.clearSearchArrListForGUI();
	}
	
	/**
	 * Reset only those ArrayLists related to search classes 
	 * collected from logic output
	 */
	private static void resetSearchLists() {
		ClashDetector.clearArrListForGUI();
		SignalHandler.clearArrListForGUI();
		SearchCommand.clearArrListForGUI();
		SearchDisplay.clearSearchArrListForGUI();
	}
	
	/**
	 * Reset only those ArrayLists related to display classes 
	 * collected from logic output
	 */
	private static void resetDisplayLists() {
		ClashDetector.clearArrListForGUI();
		SignalHandler.clearArrListForGUI();
		DisplayCommand.clearArrListForGUI();
		DisplayCategory.clearArrListForGUI();
	}
	
	/**
	 * To get the number of items for today's task list
	 */
	public static int getNumTodayItems() {
		if (todayList.isEmpty()) {
			return 0;
		} else {
			return todayList.size()-1;
		}
	}
	
	/**
	 * To get the number of items for tomorrow's task list
	 */
	public static int getNumTomorrowItems() {
		if (_tomorrowList.isEmpty()) {
			return 0;
		} else {
			return _tomorrowList.size()-1;
		}
	}
	
	/**
	 * To get the number of items for upcoming's task list
	 */
	public static int getNumUpcomingItems() {
		if (_upcomingList.isEmpty()) {
			return 0;
		} else {
			return _upcomingList.size();
		}
	}
	
	/**
	 * To get the number of items for Someday's task list
	 */
	public static int getNumSomedayItems() {
		if (_somedayList.isEmpty()) {
			return 0;
		} else {
			return _somedayList.size()-1;
		}
	}
    
	/**
	 * To get UserInput as a string type
	 */
	public static String getCurrentUserInput() {
		return _currentUserInput;
	}
	
	public static void setLogic(ClockWork l) {
		_logic = l;
	}
	
	public static ClockWork getLogic() {
		return _logic;
	}
	
}
```
