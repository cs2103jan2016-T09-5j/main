# A0129833Y
###### \logic\MarkCommand.java
``` java
/**
 * This class handles all user input with "mark" as the first keyword with the
 * format of mark <index>. It retrieves a Todo object from memory at the given
 * index, marks the Todo as done and replaces the existing copy in memory.
 */

public class MarkCommand extends Command {
	
	/**
	 * Creates a MarkCommand object.
	 * 
	 * @param input
	 *            the ParsedInput object containing the parameters.
	 * @param memory
	 *            the memory containing the Todos to which the changes should be
	 *            committed.
	 */
	public MarkCommand(ParsedInput input, Memory memory) {
		super(input, memory);
	}

	/**
	 * Retrieves the Todo object specified by index in ParsedInput from Memory
	 * and marks it as done.
	 * 
	 * @return It returns a Signal object to indicate success or failure.
	 */
	@Override
	public Signal execute() {
		// Ensure that there is only one KeyParamPair in inputList
		if (!input.containsOnlyCommand()) {
			return new Signal(Signal.MARK_INVALID_PARAMS, false);
		}

		if (input.containsEmptyParams()) {
			return new Signal(Signal.GENERIC_EMPTY_PARAM, false);
		}

		try {
			int index = Integer.parseInt(keyParamPairs.get(0).getParam());
			Todo todoToMark = memory.getToModifyTodo(index);
			todoToMark.setDone(true);
			memory.saveToFile();
			return new Signal(String.format(Signal.MARK_SUCCESS_SIGNAL_FORMAT,
					todoToMark), true);
		} catch (NullTodoException e) {
			return new Signal(e.getMessage(), false);
		} catch (NumberFormatException e) {
			return new Signal(String.format(Signal.MARK_INVALID_PARAMS), false);
		}
	}
}
```
###### \logic\RecurringTodoRule.java
``` java
/**
 * The RecurringTodoRule class contains the rules and methods for creating and
 * storing individual Todos
 *
 */
public class RecurringTodoRule implements UndoableRedoable<RecurringTodoRule> {

    private Period DEFAULT_RECURRENCE_LIMIT_PERIOD = new Period(0).withYears(1);

    protected Period recurringInterval;
    protected int recurringId;
    private DateTime recurrenceLimit;

    private String name;
    private String originalName;

    private List<DateTime> dateTimes;

    private ArrayList<Todo> recurringTodos = new ArrayList<Todo>();

    private String RECURRING_TODO_PREIX = "(Recurring) ";

    protected static final String recurringFormat = "Recurrence Rule: \"%1$s\" every %2$s until %3$s";
    protected static final String recurringDisplayFormat = "Recurrence Rule: "
            + "%1$s" + System.lineSeparator() + "Every %2$s until %3$s"
            + System.lineSeparator();
    private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormat.forPattern("EEE dd MMM yyyy");
    private static final PeriodFormatter PERIOD_FORMATTER;
    static {
    	PeriodFormatterBuilder pfb = new PeriodFormatterBuilder();
    	PERIOD_FORMATTER = pfb
    			.printZeroNever().appendYears().appendSuffix(" year(s)")
    			.printZeroNever().appendMonths().appendSuffix(" month(s)")
    			.printZeroNever().appendWeeks().appendSuffix(" week(s)")
    			.printZeroNever().appendDays().appendSuffix(" day(s)")
    			.toFormatter();
    }
       
    /**
     * Constructor for the RecurringTodoRule without specifying limit
     * 
     * @param id
     * @param recurringId
     * @param name
     * @param dateTimes
     * @param period
     */
    public RecurringTodoRule(int recurringId, String name,
            List<DateTime> dateTimes, Period period) {
        super();
        this.originalName = name;
        this.name = RECURRING_TODO_PREIX + name;
        this.dateTimes = dateTimes;
        this.recurringInterval = period;
        this.recurringId = recurringId;
        this.recurrenceLimit = new DateTime()
                .plus(DEFAULT_RECURRENCE_LIMIT_PERIOD);
    }

    /**
     * Constructor for the RecurringTodoRule with limit
     * 
     * @param id
     * @param recurringId
     * @param name
     * @param dateTimes
     * @param period
     * @param limit
     */
    public RecurringTodoRule(int recurringId, String name,
            List<DateTime> dateTimes, Period period, DateTime limit) {
        super();
        this.originalName = name;
        this.name = RECURRING_TODO_PREIX + name;
        this.dateTimes = dateTimes;
        this.recurringInterval = period;
        this.recurringId = recurringId;
        this.recurrenceLimit = limit;
    }
    
    /**
     * Create a copy of a rule. For use in EditCommand.
     * 
     * @param rule
     */
    private RecurringTodoRule(RecurringTodoRule rule) {
    	this.originalName = rule.originalName;
        this.name = rule.name;
    	this.dateTimes = rule.dateTimes;
    	this.recurringInterval = rule.recurringInterval;
    	this.recurringId = rule.recurringId;
    	this.recurrenceLimit = rule.recurrenceLimit;
    }
    
    private RecurringTodoRule(int recurringId) {
    	this.recurringId = recurringId;
    }
    
    public RecurringTodoRule copy() {
    	return new RecurringTodoRule(this);
    }
    
    public RecurringTodoRule getPlaceholder() {
    	return new RecurringTodoRule(recurringId);
    }
    
    public boolean isPlaceholder() {
    	return recurringInterval == null;
    }

    public String getName() {
        return name;
    }

    public List<DateTime> getDateTimes() {
        return dateTimes;
    }

    public ArrayList<Todo> getRecurringTodos() {
        return recurringTodos;
    }

    public Period getRecurringInterval() {
        return recurringInterval;
    }

    public int getId() {
        return recurringId;
    }

    public DateTime getRecurrenceLimit() {
        return recurrenceLimit;
    }

    /**
     * Update the list of Todos stored in the rule
     * 
     * @return the number of new Todos created due to the update
     */
    public int updateTodoList(Memory memory) {
        int currentID;
        int newTodoCount = 0;
        if (recurringTodos.isEmpty()) {
            currentID = memory.obtainFreshId();
            Todo newTodo = new Todo(currentID, name, dateTimes, recurringId);
            addFirstRecurringTodo(memory, newTodo);
            newTodoCount++;
            updateDateTime();
        }

        DateTime now = new DateTime();
        DateTime nextOccurrence = now.plus(getRecurringInterval());
        // Update until next occurrence or the limit, whichever is earlier
        DateTime updateLimit = nextOccurrence;
        if (nextOccurrence.compareTo(getRecurrenceLimit()) > 0) {
            updateLimit = getRecurrenceLimit();
        }

        while (getDateTime().compareTo(updateLimit) <= 0) {
            currentID = memory.obtainFreshId();
            Todo newTodo = new Todo(currentID, name, dateTimes, recurringId);
            addRecurringTodo(memory, newTodo);
            newTodoCount++;
            updateDateTime();
        }

        return newTodoCount;
    }

    public void setRecurrenceLimit(DateTime recurrenceLimit)
            throws InvalidParamException {
        if (recurrenceLimit == null) {
            throw new InvalidParamException(
                    "Recurring limit of recurring rule cannot be empty");
        } else {
            this.recurrenceLimit = recurrenceLimit;
        }
    }

    public void setOriginalName(String originalName) {
        this.originalName = originalName;
        this.name = RECURRING_TODO_PREIX + originalName;
    }

    public void setRecurringInterval(Period recurringInterval)
            throws InvalidParamException {
        if (recurringInterval == null) {
            throw new InvalidParamException(
                    "Recurring interval cannot be empty");
        } else {
            this.recurringInterval = recurringInterval;
        }
    }

    public void setDateTimes(List<DateTime> dateTimes)
            throws InvalidParamException {
        if (dateTimes == null || dateTimes.size() == 0) {
            throw new InvalidParamException(
                    "DateTime field of recurring rule cannot be empty");
        } else {
            this.dateTimes = dateTimes;
        }
    }

    /**
     * Add the first occurrence of the rule
     * 
     * This is considered to be added together with the rule by the user
     * 
     * @param memory
     * @param newTodo
     */
    private void addFirstRecurringTodo(Memory memory, Todo newTodo) {
        recurringTodos.add(newTodo);
        memory.userAdd(newTodo);
    }

    /**
     * Add the subsequent occurrences of the rule
     * 
     * This is considered to be added automatically by the system, not the user
     * 
     * @param memory
     * @param newTodo
     */
    private void addRecurringTodo(Memory memory, Todo newTodo) {
        recurringTodos.add(newTodo);
        memory.systemAdd(newTodo);
    }

    private void updateDateTime() {
        for (int i = 0; i < dateTimes.size(); i++) {
            if (dateTimes.get(i) != null) {
                dateTimes.set(i, dateTimes.get(i).plus(recurringInterval));
            }
        }
    }

    public String getDisplayString() {
        // Use the todo occurrence's toString result as part of the
        // display string
        Todo todoOccurrnece = new Todo(0, name, dateTimes, recurringId);
        return String.format(recurringDisplayFormat, todoOccurrnece.toString(),
                recurringInterval.toString(PERIOD_FORMATTER),
                recurrenceLimit.toString(DATE_TIME_FORMATTER));

    }

    public String toString() {
        return String.format(recurringFormat, originalName,
                recurringInterval.toString(PERIOD_FORMATTER),
                recurrenceLimit.toString(DATE_TIME_FORMATTER));
    }

    /**
     * Method to return a DateTime of the Recurring rule's last occurrence. The
     * order of preference: start time > end time > null
     * 
     * 
     * @return start time for events; end time for deadlines; null for tasks.
     */
    public DateTime getDateTime() {
        if (dateTimes.get(0) != null) {
            return dateTimes.get(0);
        } else if (dateTimes.get(1) != null) {
            return dateTimes.get(1);
        } else {
            return null;
        }
    }
}
```
###### \testcases\EditCommandTest.java
``` java
public class EditCommandTest {

	ClockWork logic;
	String nameFloating1 = " Arrange meetup";
	String nameFloating2 = " Meetup with friends";
	String nameDeadline1 = " Report submission";
	String nameDeadline2 = " Reflection submission";
	String nameEvent1 = " Dinner with Family";
	String nameEvent2 = " Dinner with extended family";
	String nameRecurring1 = " Read news";
	String nameRecurring2 = " Go to church";
	
	String date1 = " 18 May";
	int date1Day = 18;
	int date1Month = 5;
	
	String date2 = " 20 August";
	int date2Day = 20;
	int date2Month = 8;
	
	String time1 = " 2.30pm";
	int time1Hour = 14;
	int time1Min = 30;
	
	String time2 = " 4pm";
	int time2Hour = 16;
	int time2Min = 0;
	
	int year = new DateTime().getYear();
	
	String period1 = " day";
	Period period1P = new Period().withDays(1);
	String period2 = " week";
	Period period2P = new Period().withWeeks(1);
	
	String limit = " 30 December";
	int limitDay = 30;
	int limitMonth = 12;
	
	String add = "add";
	String edit = "edit";
	
	String by = " by";
	String from = " from";
	String to = " to";
	String on = " on";
	String every = " every";
	String until = " until";
	String rFlag = " -r";
	
	String idStringFloat = " 0";
	int idFloat = 0;
	String idStringDeadline = " 1";
	int idDeadline = 1;
	String idStringEvent = " 2";
	int idEvent = 2;
	String idStringRecurringTodo = " 3";
	int idRecurringTodo = 3;
	
	int idRecurring = 0;
	
	Todo floating;
	Todo deadline;
	Todo event;
	RecurringTodoRule rule;
	
	@Before
	public void setUp() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		String fileDirectory = ClockWork.getStorageFileDirFromSettings();
		logic = new ClockWork(fileDirectory);
		logic.reloadMemory();
		
		logic.handleInput(add + nameFloating1);
		logic.handleInput(add + nameDeadline1 + by + date1 + time1);
		logic.handleInput(add + nameEvent1 + from + date1 + time1 + to + date1 + time2);
		logic.handleInput(add + nameRecurring1 + every + period1);
		
		floating = new Todo(idFloat, nameFloating1.trim());
		
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date1Month, date1Day, time1Hour, time1Min);
		dateTimes.add(newDate1);
		deadline = new Todo(idDeadline, nameDeadline1.trim(), dateTimes);
		
		DateTime newDate2 = new DateTime(year, date1Month, date1Day, time2Hour, time2Min);
		dateTimes.add(newDate2);
		event = new Todo(idEvent, nameEvent1.trim(), dateTimes);
		
		List<DateTime> dateTimeRecurring = new ArrayList<DateTime>();
		dateTimeRecurring.add(newDate1);
		rule = new RecurringTodoRule(idRecurring, nameRecurring1.trim(), dateTimeRecurring, period1P);
	}
	
	@After
	public void tearDown() {
		logic.reloadMemory();
	}

	@Test
	public void testEditFloatingName() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException, NumberFormatException, NullTodoException {
		Todo floatingEdited = new Todo(idFloat, nameFloating2.trim());
		Signal signal = logic.handleInput(edit + idStringFloat + nameFloating2);
		Signal expected = new Signal(String.format(Signal.EDIT_SUCCESS_FORMAT, floating, floatingEdited), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditFloatingToDeadline() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate = new DateTime(year, date1Month, date1Day, time1Hour, time1Min);
		dateTimes.add(newDate);
		Todo deadline = new Todo(idFloat, nameFloating1.trim(), dateTimes);
		Signal signal = logic.handleInput(edit + idStringFloat + by + date1 + time1);
		Signal expected = new Signal(String.format(Signal.EDIT_SUCCESS_FORMAT, floating, deadline), true);
		assertEquals(expected, signal);
	}
	
	@Test 
	public void testEditFloatingToEvent() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date1Month, date1Day, time1Hour, time1Min);
		DateTime newDate2 = new DateTime(year, date1Month, date1Day, time2Hour, time2Min);
		dateTimes.add(newDate1);
		dateTimes.add(newDate2);
		Todo event = new Todo(idFloat, nameFloating1.trim(), dateTimes);
		Signal signal = logic.handleInput(edit + idStringFloat + from + date1 + time1 + to + date1 + time2);
		Signal expected = new Signal(String.format(Signal.EDIT_SUCCESS_FORMAT, floating, event), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditDeadlineName() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date1Month, date1Day, time1Hour, time1Min);
		dateTimes.add(newDate1);
		Todo deadline2 = new Todo(idDeadline, nameDeadline2.trim(), dateTimes);
		Signal signal = logic.handleInput(edit + idStringDeadline + nameDeadline2);
		Signal expected = new Signal(String.format(Signal.EDIT_SUCCESS_FORMAT, deadline, deadline2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditDeadlineTime() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate = new DateTime(year, date2Month, date2Day, time2Hour, time2Min);
		dateTimes.add(newDate);
		Todo deadline2 = new Todo(idDeadline, nameDeadline1.trim(), dateTimes);
		Signal signal = logic.handleInput(edit + idStringDeadline + by + date2 + time2);
		Signal expected = new Signal(String.format(Signal.EDIT_SUCCESS_FORMAT, deadline, deadline2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditDeadlineToEvent() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date1Month, date1Day, time1Hour, time1Min);
		DateTime newDate2 = new DateTime(year, date1Month, date1Day, time2Hour, time2Min);
		dateTimes.add(newDate1);
		dateTimes.add(newDate2);
		Todo event = new Todo(idDeadline, nameDeadline1.trim(), dateTimes);
		Signal signal = logic.handleInput(edit + idStringDeadline + from + date1 + time1 + to + date1 + time2);
		Signal expected = new Signal(String.format(Signal.EDIT_SUCCESS_FORMAT, deadline, event), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditEventName() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date1Month, date1Day, time1Hour, time1Min);
		DateTime newDate2 = new DateTime(year, date1Month, date1Day, time2Hour, time2Min);
		dateTimes.add(newDate1);
		dateTimes.add(newDate2);
		Todo event2 = new Todo(idEvent, nameEvent2.trim(), dateTimes);
		Signal signal = logic.handleInput(edit + idStringEvent + nameEvent2);
		Signal expected = new Signal(String.format(Signal.EDIT_SUCCESS_FORMAT, event, event2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditEventTime() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date2Month, date2Day, time1Hour, time1Min);
		DateTime newDate2 = new DateTime(year, date2Month, date2Day, time2Hour, time2Min);
		dateTimes.add(newDate1);
		dateTimes.add(newDate2);
		Todo event2 = new Todo(idEvent, nameEvent1.trim(), dateTimes);
		Signal signal = logic.handleInput(edit + idStringEvent + from + date2 + time1 + to + date2 + time2);
		Signal expected = new Signal(String.format(Signal.EDIT_SUCCESS_FORMAT, event, event2), true);
		assertEquals(expected, signal);
		
		
	}
	
	@Test
	public void testEditEventOnDateFromTimeToTime() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date2Month, date2Day, time1Hour, time1Min);
		DateTime newDate2 = new DateTime(year, date2Month, date2Day, time2Hour, time2Min);
		dateTimes.add(newDate1);
		dateTimes.add(newDate2);
		Todo event2 = new Todo(idEvent, nameEvent1.trim(), dateTimes);
		Signal signal = logic.handleInput(edit + idStringEvent + on + date2 + from + time1 + to + time2);
		Signal expected = new Signal(String.format(Signal.EDIT_SUCCESS_FORMAT, event, event2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditEventToDeadline() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date2Month, date2Day, time2Hour, time2Min);
		dateTimes.add(newDate1);
		Todo deadline2 = new Todo(idEvent, nameEvent1.trim(), dateTimes);
		Signal signal = logic.handleInput(edit + idStringEvent + by + date2 + time2);
		Signal expected = new Signal(String.format(Signal.EDIT_SUCCESS_FORMAT, event, deadline2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditRuleName() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date1Month, date1Day, time1Hour, time1Min);
		dateTimes.add(newDate1);
		RecurringTodoRule rule2 = new RecurringTodoRule(idRecurring, nameRecurring2.trim(), dateTimes, period1P);
		Signal signal = logic.handleInput(edit + idStringRecurringTodo + rFlag + nameRecurring2);
		Signal expected = new Signal(String.format(Signal.EDIT_RULE_SUCCESS_FORMAT, rule, rule2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditRulePeriod() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date1Month, date1Day, time1Hour, time1Min);
		dateTimes.add(newDate1);
		RecurringTodoRule rule2 = new RecurringTodoRule(idRecurring, nameRecurring1.trim(), dateTimes, period2P);
		Signal signal = logic.handleInput(edit + idStringRecurringTodo + rFlag + every + period2);
		Signal expected = new Signal(String.format(Signal.EDIT_RULE_SUCCESS_FORMAT, rule, rule2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditRuleLimit() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date1Month, date1Day, time1Hour, time1Min);
		dateTimes.add(newDate1);
		DateTime limitDateTime = new DateTime(year, limitMonth, limitDay, 23, 59, 00, 00);
		RecurringTodoRule rule2 = new RecurringTodoRule(idRecurring, nameRecurring1.trim(), dateTimes, period1P, limitDateTime);
		Signal signal = logic.handleInput(edit + idStringRecurringTodo + rFlag + until + limit);
		Signal expected = new Signal(String.format(Signal.EDIT_RULE_SUCCESS_FORMAT, rule, rule2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditRuleDeadlineTime() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date2Month, date2Day, time2Hour, time2Min);
		dateTimes.add(newDate1);
		RecurringTodoRule rule2 = new RecurringTodoRule(idRecurring, nameRecurring1.trim(), dateTimes, period1P);
		Signal signal = logic.handleInput(edit + idStringRecurringTodo + rFlag + by + date2 + time2);
		Signal expected = new Signal(String.format(Signal.EDIT_RULE_SUCCESS_FORMAT, rule, rule2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditRuleDeadlineToEvent() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date2Month, date2Day, time1Hour, time1Min);
		DateTime newDate2 = new DateTime(year, date2Month, date2Day, time2Hour, time2Min);
		dateTimes.add(newDate1);
		dateTimes.add(newDate2);
		RecurringTodoRule rule2 = new RecurringTodoRule(idRecurring, nameRecurring1.trim(), dateTimes, period1P);
		Signal signal = logic.handleInput(edit + idStringRecurringTodo + rFlag + from + date2 + time1 + to + date2 + time2);
		Signal expected = new Signal(String.format(Signal.EDIT_RULE_SUCCESS_FORMAT, rule, rule2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditRuleDeadlineOnFromToEvent() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date2Month, date2Day, time1Hour, time1Min);
		DateTime newDate2 = new DateTime(year, date2Month, date2Day, time2Hour, time2Min);
		dateTimes.add(newDate1);
		dateTimes.add(newDate2);
		RecurringTodoRule rule2 = new RecurringTodoRule(idRecurring, nameRecurring1.trim(), dateTimes, period1P);
		Signal signal = logic.handleInput(edit + idStringRecurringTodo + rFlag + on + date2 + from + time1 + to + time2);
		Signal expected = new Signal(String.format(Signal.EDIT_RULE_SUCCESS_FORMAT, rule, rule2), true);
		assertEquals(expected, signal);
	}
	
	@Test
	public void testEditRuleEventToDeadline() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		logic.handleInput(edit + idStringRecurringTodo + rFlag + from + date1 + time1 + to + date1 + time2);
		List<DateTime> dateTimes = new ArrayList<DateTime>();
		DateTime newDate1 = new DateTime(year, date2Month, date2Day, time1Hour, time1Min);
		DateTime newDate2 = new DateTime(year, date2Month, date2Day, time2Hour, time2Min);
		dateTimes.add(newDate1);
		dateTimes.add(newDate2);
		RecurringTodoRule rule2 = new RecurringTodoRule(idRecurring, nameRecurring1.trim(), dateTimes, period1P);
		Signal signal = logic.handleInput(edit + idStringRecurringTodo + rFlag + by + date2 + time2);
		Signal expected = new Signal(String.format(Signal.EDIT_RULE_SUCCESS_FORMAT, rule, rule2), true);
		assertEquals(expected, signal);
	}
}
```
###### \testcases\ParserTest.java
``` java
	@Test
	public void testAddRecurringEvent() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// dates: Friday to Sunday
		List<Date> dates1 = parser.parse("Friday to Sunday").get(0).getDates();
		List<DateTime> dateTimes1 = new ArrayList<DateTime>();
		for (int i = 0; i < dates1.size(); i++) {
			Date date = dates1.get(i);
			dateTimes1.add(new DateTime(date));
			dateTimes1.set(i, dateTimes1.get(i).withTime(23, 59, 0, 0));
		}

		// recurring event task
		String add1 = "add test 1 from Friday to Sunday every month";
		ParsedInput parsed1 = new ParsedInput(Keywords.ADD,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.ADD, "add", "test 1"))), dateTimes1,
				new Period().withMonths(1), true, false, new DateTime(0));

		assertEquals(parsed1, Parser.parseInput(add1));
	}

	@Test
	public void testAddRecurringDeadlineWithLimit()
			throws InvalidRecurringException, InvalidTodoNameException,
			ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: Friday
		List<Date> dates0 = parser.parse("Friday").get(0).getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}

		List<Date> dates2 = parser.parse("4 Dec 2015").get(0).getDates();
		List<DateTime> dateTimes2 = new ArrayList<DateTime>();
		for (int i = 0; i < dates2.size(); i++) {
			Date date = dates2.get(i);
			dateTimes2.add(new DateTime(date));
			dateTimes2.set(i, dateTimes2.get(i).withTime(23, 59, 0, 0));
		}

		// recurring deadline task with limit
		String add3 = "add test 3 on Friday every week until 4 Dec 2015";
		ParsedInput parsed3 = new ParsedInput(Keywords.ADD,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.ADD, "add", "test 3"))), dateTimes0,
				new Period().withWeeks(1), true, true, dateTimes2.get(0));
		assertEquals(parsed3, Parser.parseInput(add3));
	}

	@Test
	public void testAddRecurringDeadlineWithNonLimit()
			throws InvalidRecurringException, InvalidTodoNameException,
			ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: Friday
		List<Date> dates0 = parser.parse("Friday").get(0).getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}

		// recurring deadline task 'KEYWORD <valid date> + EVERY <valid period>
		// + UNTIL <invalid limit>'
		String add0 = "add test 0 on Friday every week until forever";
		ParsedInput parsed0 = new ParsedInput(Keywords.ADD,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.ADD, "add", "test 0 until forever"))),
				dateTimes0, new Period().withWeeks(1), true, false,
				new DateTime(0));

		assertEquals(parsed0, Parser.parseInput(add0));
	}

	@Test
	public void testAddRecurringEventWithLimit()
			throws InvalidRecurringException, InvalidTodoNameException,
			ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// dates: Friday to Sunday
		List<Date> dates1 = parser.parse("Friday to Sunday").get(0).getDates();
		List<DateTime> dateTimes1 = new ArrayList<DateTime>();
		for (int i = 0; i < dates1.size(); i++) {
			Date date = dates1.get(i);
			dateTimes1.add(new DateTime(date));
			dateTimes1.set(i, dateTimes1.get(i).withTime(23, 59, 0, 0));
		}

		// dates: limit 4 December 2015
		List<Date> dates2 = parser.parse("4 Dec 2015").get(0).getDates();
		List<DateTime> dateTimes2 = new ArrayList<DateTime>();
		for (int i = 0; i < dates2.size(); i++) {
			Date date = dates2.get(i);
			dateTimes2.add(new DateTime(date));
			dateTimes2.set(i, dateTimes2.get(i).withTime(23, 59, 0, 0));
		}

		// recurring event task with limit
		String add4 = "add test 4 from Friday to Sunday every month until 4 Dec 2015";
		ParsedInput parsed4 = new ParsedInput(Keywords.ADD,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.ADD, "add", "test 4"))), dateTimes1,
				new Period().withMonths(1), true, true, dateTimes2.get(0));

		assertEquals(parsed4, Parser.parseInput(add4));
	}

	@Test
	public void testAddRecurringDeadlineEveryDate()
			throws InvalidRecurringException, InvalidTodoNameException,
			ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: Friday
		List<Date> dates0 = parser.parse("4 Jan").get(0).getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}

		// recurring deadline task 'KEYWORD <valid date> + EVERY <valid period>
		String add0 = "add test 0 every 4 Jan";
		ParsedInput parsed0 = new ParsedInput(Keywords.ADD,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.ADD, "add", "test 0"))), dateTimes0,
				new Period().withYears(1), true, false, new DateTime(0));

		assertEquals(parsed0, Parser.parseInput(add0));
	}

	@Test(expected = InvalidRecurringException.class)
	public void testAddInvalidRecurring() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: 4 Dec 2015
		List<Date> dates0 = parser.parse("4 Dec 2015").get(0).getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}
		// invalid recurring command: name + every <valid period> + <valid
		// limit>
		String add0 = "add test 5 every month until 4 Dec 2015";
		ParsedInput parsed0 = new ParsedInput(Keywords.ADD,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.ADD, "add", "test 5"))),
				new ArrayList<DateTime>(), new Period().withMonths(1), false,
				true, dateTimes0.get(0));
		assertEquals(parsed0, Parser.parseInput(add0));
	}

	@Test(expected = ParsingFailureException.class)
	public void testAddTaskWithMoreThanTwoDateTimes()
			throws InvalidRecurringException, InvalidTodoNameException,
			ParsingFailureException {
		String add0 = "add event from 1 Jan to 2 Jan in 2 days";
		Parser.parseInput(add0);
	}

	@Test
	public void testEditName() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {

		String edit0 = "edit 1 change name";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "1 change name"))),
				new ArrayList<DateTime>(), new Period(), false, false,
				new DateTime(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test(expected = InvalidTodoNameException.class)
	public void testEditInvalidName() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		String edit0 = "edit 1 -n";
		Parser.parseInput(edit0);
	}

	@Test(expected = ParsingFailureException.class)
	public void testEditMoreThanTwoDateTimes()
			throws InvalidRecurringException, InvalidTodoNameException,
			ParsingFailureException {
		String edit0 = "edit 4 from 5 June to 6 June on 8 June";
		Parser.parseInput(edit0);
	}

	@Test
	public void testEditTo() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: 4 Dec 2015
		List<Date> dates0 = parser.parse("4 Dec 2015").get(0).getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}

		String edit0 = "edit 1 to 4 Dec 2015";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "1"), new KeyParamPair(
						Keywords.TO, "to", "4 Dec 2015"))), dateTimes0,
				new Period(), false, false, new DateTime(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testEditStart() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: 4 Dec 2015
		List<Date> dates0 = parser.parse("4 Dec 2015").get(0).getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}

		String edit0 = "edit 1 from 4 Dec 2015";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "1"), new KeyParamPair(
						Keywords.FROM, "from", "4 Dec 2015"))), dateTimes0,
				new Period(), false, false, new DateTime(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testEditEnd() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: 4 Dec 2015
		List<Date> dates0 = parser.parse("4 Dec 2015").get(0).getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}

		String edit0 = "edit 1 on 4 Dec 2015";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "1"), new KeyParamPair(
						Keywords.ON, "on", "4 Dec 2015"))), dateTimes0,
				new Period(), false, false, new DateTime(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testEditStartAndEnd() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: 3 Dec 2015 and 4 Dec 2015
		List<Date> dates0 = parser.parse("3 Dec 2015 to 4 Dec 2015").get(0)
				.getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}

		String edit0 = "edit 1 from 3 Dec 2015 to 4 Dec 2015";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "1"), new KeyParamPair(
						Keywords.FROM, "from", "3 Dec 2015"), new KeyParamPair(
						Keywords.TO, "to", "4 Dec 2015"))), dateTimes0,
				new Period(), false, false, new DateTime(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testEditRecurringName() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		String edit0 = "edit 1 -r change name";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "1 change name"),
						new KeyParamPair(Keywords.RULE, "-r", ""))),
				new ArrayList<DateTime>(), new Period(), false, false,
				new DateTime(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testEditRecurringStartAndEnd()
			throws InvalidRecurringException, InvalidTodoNameException,
			ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: 3 Dec 2015 and 4 Dec 2015
		List<Date> dates0 = parser.parse("3 Dec 2015 to 4 Dec 2015").get(0)
				.getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}

		String edit0 = "edit 1 -r from 3 Dec 2015 to 4 Dec 2015";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "1"), new KeyParamPair(
						Keywords.RULE, "-r", ""), new KeyParamPair(
						Keywords.FROM, "from", "3 Dec 2015"), new KeyParamPair(
						Keywords.TO, "to", "4 Dec 2015"))), dateTimes0,
				new Period(), false, false, new DateTime(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testEditRecurringPeriod() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		String edit0 = "edit 1 -r every week";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "1"), new KeyParamPair(
						Keywords.RULE, "-r", ""), new KeyParamPair(
						Keywords.EVERY, "every", "week"))),
				new ArrayList<DateTime>(), new Period().withWeeks(1), true,
				false, new DateTime(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testEditRecurringLimit() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: 1 jan 2016
		List<Date> dates1 = parser.parse("1 jan 2016").get(0).getDates();
		List<DateTime> dateTimes1 = new ArrayList<DateTime>();
		for (int i = 0; i < dates1.size(); i++) {
			Date date = dates1.get(i);
			dateTimes1.add(new DateTime(date));
			dateTimes1.set(i, dateTimes1.get(i).withTime(23, 59, 0, 0));
		}

		String edit0 = "edit 1 -r until 1 jan 2016";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "1"), new KeyParamPair(
						Keywords.RULE, "-r", ""), new KeyParamPair(
						Keywords.UNTIL, "until", "1 jan 2016"))),
				new ArrayList<DateTime>(), new Period(), true, true,
				dateTimes1.get(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testEditRecurringStartAndEndWithLimit()
			throws InvalidRecurringException, InvalidTodoNameException,
			ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: from 3 Dec 2015 to 4 Dec 2015
		List<Date> dates0 = parser.parse("3 Dec 2015 to 4 Dec 2015").get(0)
				.getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}

		// date: 1 jan 2016
		List<Date> dates1 = parser.parse("1 jan 2016").get(0).getDates();
		List<DateTime> dateTimes1 = new ArrayList<DateTime>();
		for (int i = 0; i < dates1.size(); i++) {
			Date date = dates1.get(i);
			dateTimes1.add(new DateTime(date));
			dateTimes1.set(i, dateTimes1.get(i).withTime(23, 59, 0, 0));
		}

		String edit0 = "edit 0 -r from 3 Dec 2015 to 4 Dec 2015 until 1 jan 2016";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "0"), new KeyParamPair(
						Keywords.RULE, "-r", ""), new KeyParamPair(
						Keywords.FROM, "from", "3 Dec 2015"), new KeyParamPair(
						Keywords.UNTIL, "until", "1 jan 2016"),
						new KeyParamPair(Keywords.TO, "to", "4 Dec 2015"))),
				dateTimes0, new Period(), true, true, dateTimes1.get(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testEditRecurringNameWithLimit()
			throws InvalidRecurringException, InvalidTodoNameException,
			ParsingFailureException {

		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: 1 jan 2016
		List<Date> dates1 = parser.parse("1 jan 2016").get(0).getDates();
		List<DateTime> dateTimes1 = new ArrayList<DateTime>();
		for (int i = 0; i < dates1.size(); i++) {
			Date date = dates1.get(i);
			dateTimes1.add(new DateTime(date));
			dateTimes1.set(i, dateTimes1.get(i).withTime(23, 59, 0, 0));
		}
		String edit0 = "edit 0 -r new name until 1 jan 2016";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "0 new name"), new KeyParamPair(
						Keywords.RULE, "-r", ""), new KeyParamPair(
						Keywords.UNTIL, "until", "1 jan 2016"))),
				new ArrayList<DateTime>(), new Period(), true, true,
				dateTimes1.get(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testEditRecurringWithNonPeriod()
			throws InvalidRecurringException, InvalidTodoNameException,
			ParsingFailureException {
		String edit0 = "edit 1 -r every one";
		ParsedInput parsed0 = new ParsedInput(Keywords.EDIT,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.EDIT, "edit", "1 every one"),
						new KeyParamPair(Keywords.RULE, "-r", ""),
						new KeyParamPair(Keywords.EVERY, "every", "one"))),
				new ArrayList<DateTime>(), new Period(), false, false,
				new DateTime(0));
		assertEquals(parsed0, Parser.parseInput(edit0));
	}

	@Test
	public void testSearchFlagName() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		String search0 = "search -n name";
		ParsedInput parsed0 = new ParsedInput(Keywords.SEARCH,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.SEARCH, "search", ""), new KeyParamPair(
						Keywords.NAME, "-n", "name"))), new ArrayList<DateTime>(),
				new Period(), false, false, new DateTime(0));

		assertEquals(parsed0, Parser.parseInput(search0));
	}
	
	@Test
	public void testSearchName() throws InvalidRecurringException, InvalidTodoNameException, ParsingFailureException {
		String search0 = "search name";
		ParsedInput parsed0 = new ParsedInput(Keywords.SEARCH,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.SEARCH, "search", "name"))), new ArrayList<DateTime>(),
				new Period(), false, false, new DateTime(0));

		assertEquals(parsed0, Parser.parseInput(search0));
	}
	
	@Test
	public void testSearchYear() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {
		com.joestelmach.natty.Parser parser = new com.joestelmach.natty.Parser(
				TimeZone.getDefault());

		// date: 2016
		List<Date> dates0 = parser.parse("march 2016").get(0).getDates();
		List<DateTime> dateTimes0 = new ArrayList<DateTime>();
		for (int i = 0; i < dates0.size(); i++) {
			Date date = dates0.get(i);
			dateTimes0.add(new DateTime(date));
			dateTimes0.set(i, dateTimes0.get(i).withTime(23, 59, 0, 0));
		}

		String search0 = "search -y 2016";
		ParsedInput parsed0 = new ParsedInput(Keywords.SEARCH,
				new ArrayList<KeyParamPair>(Arrays.asList(new KeyParamPair(
						Keywords.SEARCH, "search", ""), new KeyParamPair(
						Keywords.YEAR, "-y", "march 2016"))), dateTimes0,
				new Period(), false, false, new DateTime(0));

		assertEquals(parsed0, Parser.parseInput(search0));

	}

	@Test(expected = InvalidTodoNameException.class)
	public void testAddFlagName() throws InvalidRecurringException,
			InvalidTodoNameException, ParsingFailureException {

		String add0 = "add -y";
		Parser.parseInput(add0);
	}
}
```
###### \userinterface\BoxFeedback.java
``` java
/**
 * The BoxFeedback class creates the layout to display feedback based
 * on the user input to the user.
 */
public class BoxFeedback extends StackPane {
	/** Constructor for BoxFeedback object */
	public BoxFeedback() {
		this.setPadding(new Insets(10,10,10,10));
		this.setStyle("-fx-background-color: #182733;");
	}
}
```
###### \userinterface\BoxHeader.java
``` java
/**
 * The BoxHeader class creates the layout to display the date, and available shortcuts
 * the user may use by using FontAwesome icons.
 */
public class BoxHeader extends BorderPane {
	/** Enumerator for nodes used in BoxHeader */
	private enum NODETYPE { 
		HELP, CALENDAR, SUMMARY, MINIMIZE, ESCAPE 
	};
	
	/** Nodes containing both label and icon to display in BoxHeader */
	private Node helpNode;
	private Node calendarNode;
	private Node minimiseNode;
	private Node escapeNode;
	private Node summaryNode;
	
	/** Label for the boxes used to set the nodes */
	private static final Label LABEL_DATE = new Label("     "+ DisplayCategory.getTodayDate()+"     ");
	private static final Label LABEL_HELP = new Label("F1");
	private static final Label LABEL_CALENDAR = new Label("F2");
	private static final Label LABEL_SUMMARY = new Label("F3");
	private static final Label LABEL_MINIMIZE = new Label("Del");
	private static final Label LABEL_ESCAPE = new Label("Esc");
	private static final Label LABEL_DUMMY = new Label(" ");

	/** Icons for the boxes used to set the nodes */
	private final Node ICON_HELP = GlyphsDude.createIcon(FontAwesomeIcon.QUESTION);
	private final Node ICON_CALENDAR = GlyphsDude.createIcon(FontAwesomeIcon.CALENDAR);
	private final Node ICON_SUMMARY = GlyphsDude.createIcon(FontAwesomeIcon.TH_LARGE);
	private final Node ICON_MINIMIZE = GlyphsDude.createIcon(FontAwesomeIcon.MINUS);
	private final Node ICON_ESCAPE = GlyphsDude.createIcon(FontAwesomeIcon.REPLY);
	
	/** Background colour for nodes */
	private static final String STYLE_BOX_HEADER = "-fx-background-color: #272b39;";
	
	/** Constructor for BoxHeader object*/
	public BoxHeader() {
		implementHeaderNodes();
		this.setLeft(createDateBox());
		this.setRight(createShortcutBox());
		this.setStyle(STYLE_BOX_HEADER);
	}
	
	/** Implement all nodes to be used for shortcut box */
	private void implementHeaderNodes() {
		helpNode = createNode(NODETYPE.HELP);
		calendarNode = createNode(NODETYPE.CALENDAR);
		minimiseNode = createNode(NODETYPE.MINIMIZE);
		escapeNode = createNode(NODETYPE.ESCAPE);
		summaryNode = createNode(NODETYPE.SUMMARY);
	}
	
	/** Create date box to contain date for left side of HeaderBox */
	private BoxHeaderInnerBox createDateBox(){
		BoxHeaderInnerBox dateBox = new BoxHeaderInnerBox();
		Node dateNode = Borders.wrap(LABEL_DATE).lineBorder().color(Color.WHITE).build().build();
		dateBox.setLeft(dateNode);
		
		return dateBox;
	}
	
	/** Create shortcut box to contain nodes for right side of HeaderBox */
	private Node createShortcutBox(){
		BoxHeaderInnerBox shortcutsBox = new BoxHeaderInnerBox();
		
		BoxHeaderInnerBox helpCalBox = createLeftShortcutBox();
		BoxHeaderInnerBox minSumBox = createCenterShortcutBox();
		BoxHeaderInnerBox escBox = createRightShortcutBox();
		
		shortcutsBox.setLeft(helpCalBox);
		shortcutsBox.setCenter(minSumBox);
		shortcutsBox.setRight(escBox);
		
		return shortcutsBox;
	}
	
	/** Create left section of shortcut box */
	private BoxHeaderInnerBox createLeftShortcutBox() {
		BoxHeaderInnerBox helpCalBox = new BoxHeaderInnerBox();
		helpCalBox.setLeft(helpNode);
		helpCalBox.setRight(calendarNode);
		return helpCalBox;
	}
	
	/** Create center section of shortcut box */
	private BoxHeaderInnerBox createCenterShortcutBox() {
		BoxHeaderInnerBox minSumBox = new BoxHeaderInnerBox();
		minSumBox.setLeft(summaryNode);
		minSumBox.setRight(minimiseNode);
		return minSumBox;
	}
	
	/** Create right section of shortcut box */
	private BoxHeaderInnerBox createRightShortcutBox() {
		BoxHeaderInnerBox escBox = new BoxHeaderInnerBox();
		escBox.setCenter(escapeNode);
		return escBox;
	}

	/** Create all nodes to be used for shortcut box */
	private Node createNode(NODETYPE type) {
		BoxHeaderInnerBox nodeBox = new BoxHeaderInnerBox();
		switch (type){
		case HELP:
			nodeBox.setTop(LABEL_HELP);
			nodeBox.setBottom(ICON_HELP);
			break;
		case CALENDAR:
			nodeBox.setTop(LABEL_CALENDAR);
			nodeBox.setBottom(ICON_CALENDAR);
			break;
		case SUMMARY:
			nodeBox.setTop(LABEL_SUMMARY);
			nodeBox.setBottom(ICON_SUMMARY);
			break;
		case MINIMIZE:
			nodeBox.setTop(LABEL_MINIMIZE);
			nodeBox.setBottom(ICON_MINIMIZE);
			break;
		default:
			nodeBox.setTop(LABEL_ESCAPE);
			nodeBox.setBottom(ICON_ESCAPE);
		
		}
		nodeBox.setCenter(LABEL_DUMMY);
		
		Node node = Borders.wrap(nodeBox).lineBorder().color(Color.WHITE).build().build();

		return node;
	}
}
```
###### \userinterface\BoxHeaderInnerBox.java
``` java
/**
* The BoxHeaderInnerBox class creates the layout to place nodes from the BoxHeader class.
*/
public class BoxHeaderInnerBox extends BorderPane {
	/** Constructor for BoxHeaderInnerBox object*/
	public BoxHeaderInnerBox() {
		this.setStyle("-fx-background-color: #272b39;");
	}
}
```
###### \userinterface\BoxInput.java
``` java
/**
* The BoxInput class creates the textfield for user input and links the textfield 
* to the Controller class to handle user input and key events.
*/
public class BoxInput extends TextField {
	/** Constructor for BoxInput object*/
	public BoxInput() {
		Controller.implementKeystrokeEvents(this);
		this.setStyle("-fx-background-color: #272b39; -fx-text-inner-color: white;");
	}
}
```
###### \userinterface\BoxTask.java
``` java
/**
 * The BoxTask class creates the layout used to contain the nodes used to display
 * user tasks to the user.
 */
public class BoxTask extends BorderPane{
	/** Constructor for BoxTask object*/
	public BoxTask() {
		this.setStyle("-fx-background-color: #182733;");
		this.setPadding(new Insets(10,10,10,10));
	}

}
```
###### \userinterface\clockwork.css
``` css
.label {
	-fx-text-fill: #FFFFFF;
}

.text {
	-fx-text-fill: #FFFFFF;
}

.button {
	-fx-background-color: transparent;
}
.button:focused {
    -fx-background-color: rgba(0, 100, 100, 0.5);
}

.glyph-icon {
	-fx-fill: #FFFFFF;
}

.hbox {
	-fx-background-color: #182733;
}

.grid {
	-fx-background-color: #182733;
}

.border-pane {
	-fx-background-color: #182733;
}

.scroll-pane {
    -fx-background-color:transparent;
}

.table-view{
   -fx-background-color: #182733;
}

.table-view .column-header-background{
    -fx-background-color: rgba(0, 100, 100, 0.5);
}

.table-view .column-header-background .label{
    -fx-background-color: transparent;
    -fx-text-fill: white;
}

.table-view .column-header {
    -fx-background-color: transparent;
}

.table-cell:filled:selected:focused, .table-cell:filled:selected {
    -fx-background-color: #182733;
    -fx-text-fill: white;
}

.table-cell:odd { 
    -fx-background-color: #182733;
    -fx-text-fill: white;
}

.table-cell:even { 
    -fx-background-color: #182733;
    -fx-text-fill: white;
}

.table-cell:filled:hover {
    -fx-background-color: #182733;
    -fx-text-fill: white;
}

#calendar-control {
	-fx-padding: 1;  
	-fx-background-insets: 0, 100;
	-fx-background-radius: 0, 0; 
	-fx-background-color: rgba(0, 100, 100, 0.1);
}
```
###### \userinterface\LayoutCategory.java
``` java
/**
* The LayoutCategory class creates the layout to display the category buttons to the user. The 
* category button comprising of Today, Tomorrow, Upcoming and Someday can be clicked by pressing
* Tab+Enter to navigate to the corresponding folders containing tasks of the four types. 
*/
public class LayoutCategory extends BorderPane {
	/** Buttons for navigation for each category */
	private Button todayButton = new Button();
	private Button tomorrowButton = new Button();
	private Button upcomingButton = new Button();
	private Button somedayButton = new Button();
	
	/** Rectangles to display for each category */
	private LayoutCategoryRectangle rectToday = new LayoutCategoryRectangle();
	private LayoutCategoryRectangle rectTomorrow = new LayoutCategoryRectangle();
	private LayoutCategoryRectangle rectUpcoming = new LayoutCategoryRectangle();
	private LayoutCategoryRectangle rectSomeday = new LayoutCategoryRectangle();
	
	/** Stackpanes to contain the rectangles and buttons for each category  */
	private StackPane spToday = new StackPane();
	private StackPane spTomorrow = new StackPane();
	private StackPane spUpcoming = new StackPane();
	private StackPane spSomeday = new StackPane();
	
	/** Strings to display on each category  */
	private static final String todayString = "Today";
	private static final String tomorrowString = "Tomorrow";
	private static final String upcomingString = "Upcoming";
	private static final String somedayString = "Someday";
	
	/** Integers to denote the number to display for each category */
	private int _numToday;
	private int _numTomorrow;
	private int _numUpcoming;
	private int _numSomeday;
	
	/** Integers to denote the size of the buttons */
	private final int WIDTH_BUTTON_SIZE = 150;
	private final int HEIGHT_BUTTON_SIZE = 150;
	
	/** Layouts used to contain the categories */
	private GridPane categoryButtons = new GridPane();
	private HBox categoryRow = new HBox();
	private GridPane categoryGrid = new GridPane();
	
	/**
	 * Creates a LayoutCategory object.
	 * 
	 * @param numToday				The number of items shown on box for Today
	 * @param numTomorrow			The number of items shown on box for Tomorrow
	 * @param numUpcoming			The number of items shown on box for Upcoming
	 * @param numSomeday			The number of items shown on box for Tomorrow
	 */
	public LayoutCategory(int numToday, int numTomorrow, int numUpcoming, int numSomeday) {
		_numToday = numToday;
		_numTomorrow = numTomorrow;
		_numUpcoming = numUpcoming;
		_numSomeday = numSomeday;
		
		setBottomRegion();
		setTopRegion();
		setCenterRegion();
	}

	/** Set top region to display available shortcuts */
	private void setTopRegion() {
		BoxHeader headerBox = new BoxHeader();
		this.setTop(headerBox);
	}
	
	/** Set center region to display the four categories */
	private void setCenterRegion() {		
		implementCategoryBoxes();
		implementCategoryButtons();
		implementCategoryRow();
		this.setCenter(createCategoryGrid());
	}
	
	/** Set bottom region for user input */
	private void setBottomRegion() {
		BoxInput textField = new BoxInput();
		textField = implementTextField(textField);
		
		this.setBottom(textField);
	}
	
	/** Implement category boxes for each category */
	private void implementCategoryBoxes(){
		spToday.getChildren().addAll(rectToday, 
				createCategoryButton(todayButton, todayString, 
						createCategoryButtonString(todayString, _numToday)));
		spTomorrow.getChildren().addAll(rectTomorrow, 
				createCategoryButton(tomorrowButton, tomorrowString, 
						createCategoryButtonString(tomorrowString, _numTomorrow)));
		spUpcoming.getChildren().addAll(rectUpcoming,
				createCategoryButton(upcomingButton, upcomingString, 
						createCategoryButtonString(upcomingString, _numUpcoming)));
		spSomeday.getChildren().addAll(rectSomeday, 
				createCategoryButton(somedayButton, somedayString, 
						createCategoryButtonString(somedayString, _numSomeday)));
	}
	
	/** Implement category buttons for each category */
	private void implementCategoryButtons(){
		categoryButtons.add(spToday, 0, 0);
		categoryButtons.add(spTomorrow, 1, 0);
		categoryButtons.add(spUpcoming, 0, 1);
		categoryButtons.add(spSomeday, 1, 1);
	}
	
	/** Implement category row to centralize all category buttons */
	private void implementCategoryRow(){
		categoryRow.getChildren().add(categoryButtons);
		categoryRow.setAlignment(Pos.CENTER);
	}
	
	/** Implement the textfield for user to enter input */
	private BoxInput implementTextField(BoxInput textField) {
		textField.setEditable(false);
		textField.setOnKeyPressed(new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent ke) {
				if (ke.getCode().equals(KeyCode.ESCAPE)) {
					Controller.processEnter("DISPLAY");
				}
				Controller.executeKeyPress(textField, ke);
			}
		});
		return textField;
	}
	
	/** Create category grid for all category boxes */
	private GridPane createCategoryGrid(){
		categoryGrid.getChildren().add(categoryRow);
		categoryGrid.setAlignment(Pos.CENTER);
		categoryGrid.setStyle("-fx-background-color: #182733");

		ColumnConstraints categoryColumnConstraints = new ColumnConstraints();
		categoryColumnConstraints.setFillWidth(true);
		categoryColumnConstraints.setHgrow(Priority.ALWAYS);
		categoryGrid.getColumnConstraints().add(categoryColumnConstraints);
		
		return categoryGrid;
	}
	
	/** Create category button string to add on each button */
	private String createCategoryButtonString(String categoryType, int numItems){
		String categoryString = categoryType + "\n" + Integer.toString(numItems) + " Item(s)";
		return categoryString;
	}
	
	/** Create category button for each category */
	private Node createCategoryButton(Button button, String categoryType, String categoryString){
		button.setText(categoryString);
		button.setWrapText(true);
		button.setPrefSize(WIDTH_BUTTON_SIZE, HEIGHT_BUTTON_SIZE);
		button.setTextFill(Color.WHITE);
		Controller.redirectScene(button, categoryType);
		Node buttonNode = Borders.wrap(button).lineBorder().color(Color.AQUAMARINE).build().build();
		return buttonNode;
	}
}
```
###### \userinterface\LayoutCategoryRectangle.java
``` java
/**
* The LayoutSummaryRectangle class creates the rectangles used in the four boxes of
* the LayoutSummary class.
*/
public class LayoutCategoryRectangle extends Rectangle {
	/** Constructor for LayoutSummaryRectangle object*/
	public LayoutCategoryRectangle(){
		this.setWidth(150);
		this.setHeight(150);
		this.setFill(Color.TRANSPARENT);
	}
}
```
###### \userinterface\LayoutHelp.java
``` java
/**
* The LayoutHelp class creates the layout to display help to the user. The available command 
* types the user can use, as well as the input format to call the commands are shown in this 
* class to visually aid the user in using Clockwork.
*/
public class LayoutHelp extends BorderPane {
	/** Enumerator for nodes used in BoxHeader */
	private enum NODETYPE { ADD, DELETE, EDIT, SEARCH, MARK, UNDO, REDO, EXIT, FORMAT };
	
	/** Strings to display in the help bar */
	private static final String TEXT_NODE_ADD = "Add";
	private static final String TEXT_NODE_DELETE = "Delete";
	private static final String TEXT_NODE_EDIT = "Edit";
	private static final String TEXT_NODE_SEARCH = "Search";
	private static final String TEXT_NODE_MARK = "Mark";
	private static final String TEXT_NODE_UNDO = "Undo";
	private static final String TEXT_NODE_REDO = "Redo";
	private static final String TEXT_NODE_EXIT = "Exit";
	private static final String TEXT_NODE_FORMAT = "<Tab>";
	
	/** Icons to display in the help bar */
	private final Node ICON_ADD = GlyphsDude.createIcon(FontAwesomeIcon.PLUS);
	private final Node ICON_DELETE = GlyphsDude.createIcon(FontAwesomeIcon.MINUS);
	private final Node ICON_EDIT = GlyphsDude.createIcon(FontAwesomeIcon.PENCIL);
	private final Node ICON_SEARCH = GlyphsDude.createIcon(FontAwesomeIcon.SEARCH);
	private final Node ICON_MARK = GlyphsDude.createIcon(FontAwesomeIcon.CHECK);
	private final Node ICON_UNDO = GlyphsDude.createIcon(FontAwesomeIcon.UNDO);
	private final Node ICON_REDO = GlyphsDude.createIcon(FontAwesomeIcon.REPEAT);
	private final Node ICON_EXIT = GlyphsDude.createIcon(FontAwesomeIcon.CLOSE);
	private final Node ICON_FORMAT = GlyphsDude.createIcon(FontAwesomeIcon.INFO);
	
	/** Background colour for nodes */
	private final String STYLE_MAIN_BORDERPANE = "-fx-background-color: #182733";
	private final String STYLE_MAIN_STACKPANE = "-fx-background-color: #182733";
	private final String STYLE_HELPBOX = "-fx-background-color: #182733";
	private final String STYLE_CONTENT_BAR = "-fx-background-color: rgba(0, 100, 100, 0.5); -fx-background-radius: 10;";
	
	/** Dimensions of items used in the class */
	private static final int HEIGHT_CONTENT_BOX = 300;
	private static final int HEIGHT_MAIN_STACKPANE = 150;
	private static final int WIDTH_MAIN_STACKPANE = 900;
	
	/** Dummy label used to set a placeholder for nodes */
	private static final Label LABEL_DUMMY = new Label(" ");
	
	/** Nodes containing both label and icon to display in BoxHeader */
	private Node addNode;
	private Node deleteNode;
	private Node editNode;
	private Node searchNode;
	private Node markNode;
	private Node undoNode;
	private Node redoNode;
	private Node exitNode;
	private Node formatNode;
	
	/** Layouts used to contain the help nodes */
	private StackPane formatBox = new StackPane();
	private GridPane barBox = new GridPane();
	private HBox helpBar = new HBox();
	private BorderPane helpBox = new BorderPane();
	
	/** Text used to show available command formats */
	private Text formatText = new Text();
	
	/** String used to show available command formats */
	private static final String formatString = new String(
			"add [task name] from [starting period] to [ending period]\n"
			+ "delete [task IDs] \n"
			+ "edit <ID> [<newName>] [from <newStartTime>] [ to <newEndTime>] "
			+ "[by;on;at <newDeadline>] [every  <interval> ] [until <limit>] \n"
			+ "search [<taskName>; <date>] \n"
			+ "mark <ID>");

	/** Constructor for LayoutHelp object*/
	public LayoutHelp() {
		setBottomRegion();
		setTopRegion();
		setCenterRegion();
	}

	/** Set top region to display available shortcuts */
	private void setTopRegion() {	
		BoxHeader headerBox = new BoxHeader();
		this.setTop(headerBox);
	}
	
	/** Set center region to display available help commands and input format */
	private void setCenterRegion() {
		implementHelpNodes();
		implementHelpBar();
		createFormatText();
		this.setCenter(createHelpBox());
	}

	/** Set bottom region for user input */
	private void setBottomRegion() {
		this.setBottom(implementTextField());
	}
	
	/** Implement all nodes to be used for help bar */
	private void implementHelpNodes() {
		addNode = createNode(NODETYPE.ADD);
		deleteNode = createNode(NODETYPE.DELETE);
		editNode = createNode(NODETYPE.EDIT);
		searchNode = createNode(NODETYPE.SEARCH);
		markNode = createNode(NODETYPE.MARK);
		undoNode = createNode(NODETYPE.UNDO);
		redoNode = createNode(NODETYPE.REDO);
		formatNode = createNode(NODETYPE.FORMAT);
		exitNode = createNode(NODETYPE.EXIT);
	}
	
	/** Implement the help bar that holds the help nodes */
	private void implementHelpBar() {
		helpBar.getChildren().addAll(
				addNode, deleteNode, editNode, searchNode, markNode, 
				undoNode, redoNode, exitNode, formatNode);
		helpBar.setAlignment(Pos.CENTER);
		helpBar.setStyle(STYLE_CONTENT_BAR);
	}
	
	/** Implement the textfield for user to enter input */
	private TextField implementTextField() {
		BoxInput textField = new BoxInput();
		textField.setEditable(false);
		textField.setOnKeyPressed(new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent ke) {
				if (ke.getCode().equals(KeyCode.ESCAPE)) {
					Controller.processEnter("DISPLAY");
				}
				Controller.executeKeyPress(textField, ke);
			}
		});
		return textField;
	}
	
	/** Creates the help box containing the help bar and the input format help box */
	private BorderPane createHelpBox(){
		helpBox.setStyle(STYLE_MAIN_BORDERPANE);
		helpBox.setTop(createBarBox());
		helpBox.setBottom(createFormatBox());
		return helpBox;
	}
	
	/** Creates the box that holds the help bar */
	private GridPane createBarBox() {	
		barBox.getChildren().add(helpBar);
		barBox.setAlignment(Pos.BOTTOM_CENTER);
		barBox.setStyle(STYLE_HELPBOX);
		barBox.setPrefHeight(HEIGHT_CONTENT_BOX);
		
		ColumnConstraints barColumnConstraints = new ColumnConstraints();
		barColumnConstraints.setFillWidth(true);
		barColumnConstraints.setHgrow(Priority.ALWAYS);
		barBox.getColumnConstraints().add(barColumnConstraints);
		
		return barBox;
	}
	
	/** Creates the box that holds the input format help */
	private StackPane createFormatBox(){
		formatBox.setStyle(STYLE_MAIN_STACKPANE);
		formatBox.setPrefSize(WIDTH_MAIN_STACKPANE, HEIGHT_MAIN_STACKPANE);
		formatBox.getChildren().add(formatText);
		return formatBox;
	}

	/** Creates a Node of the specified NODETYPE */
	private Node createNode(NODETYPE type){
		BorderPane nodeBox = new BorderPane();
		Label label = null;
		Node icon = null;
		switch (type){
		case ADD:
			label = new Label(TEXT_NODE_ADD);
			icon = ICON_ADD;
			break;
		case DELETE:
			label = new Label(TEXT_NODE_DELETE);
			icon = ICON_DELETE;
			break;
		case EDIT:
			label = new Label(TEXT_NODE_EDIT);
			icon = ICON_EDIT;
			break;
		case SEARCH:
			label = new Label(TEXT_NODE_SEARCH);
			icon = ICON_SEARCH;
			break;
		case MARK:
			label = new Label(TEXT_NODE_MARK);
			icon = ICON_MARK;
			break;
		case UNDO:
			label = new Label(TEXT_NODE_UNDO);
			icon = ICON_UNDO;
			break;
		case REDO:
			label = new Label(TEXT_NODE_REDO);
			icon = ICON_REDO;
			break;
		case EXIT:
			label = new Label(TEXT_NODE_EXIT);
			icon = ICON_EXIT;
			break;
		default:
			label = new Label(TEXT_NODE_FORMAT);
			icon = ICON_FORMAT;
			break;
		}
		
		nodeBox.setTop(label);
		nodeBox.setCenter(LABEL_DUMMY);
		nodeBox.setBottom(icon);
		Node node = Borders.wrap(nodeBox).lineBorder().color(Color.WHITE).build().build();
		return node;
	}
	
	/** Create input format help to show available command formats */
	private void createFormatText(){
		formatText = new Text(formatString);
		formatText.setFill(Color.WHITE);
	}
}
```
###### \userinterface\LayoutTemplate.java
``` java
/**
 * The LayoutTemplate class creates the layout to display the table containing
 * all tasks to the user.
 */
public class LayoutTemplate extends BorderPane {

	/** Lists to display in the table and feedback box */
	private ArrayList<String[]> _list = new ArrayList<String[]>();
	private ArrayList<String> _feedbackList;

	/** Boolean to display date column and enable Esc key to change scene */
	private boolean _shouldDisplayDate;
	private boolean _shouldEnableEscape;

	/** Integer to store size of task list */
	private int _listSize;

	/** Nodes to display layout title */
	private Label _titleLabel;
	private String _titleString;
	private Node _titleNode;

	/** Keys for the stored tasks in the HashMap */
	public static final String KEY_COLUMN_INDEX = "Index";
	public static final String KEY_COLUMN_NAME = "Name";
	public static final String KEY_COLUMN_TIME = "Time";
	public static final String KEY_COLUMN_DATE = "Date";

	/** Settings for the scrollpane scrolling speed */
	private static int currentScrollIndex = 0;
	private static final int SPEED_SCROLL_DOWN = 3;
	private static final int SPEED_SCROLL_UP = -3;

	/** Indexes of the task variables in the string array */
	private final int INDEX_TASK_INDEX = 0;
	private final int INDEX_TASK_NAME = 1;
	private final int INDEX_TASK_TIME = 2;
	private final int INDEX_TASK_DATE = 3;

	/** Styling for the objects in the scene */
	public static final String STYLE_CENTRE_REGION = "-fx-background-color: #182733;";
	public static final String STYLE_USER_BOX = "-fx-background-color: #182733;";
	public static final String FONT_FEEDBACK = "Calibri";

	/** Sizes for the elements in the scene */
	private final int FONTSIZE_FEEDBACK = 12;

	/** Display sizes if the scene has 3 columns */
	private final int WIDTH_WRAPPING_FEEDBACK = 500;
	private final int WIDTH_DISPLAY3_WRAPPING_DATACOLUMN_1 = 10;
	private final int WIDTH_DISPLAY3_WRAPPING_DATACOLUMN_2 = 460;
	private final int WIDTH_DISPLAY3_WRAPPING_DATACOLUMN_3 = 290;

	/** Display sizes if the scene has 4 columns */
	private final int WIDTH_DISPLAY4_WRAPPING_DATACOLUMN_1 = 20;
	private final int WIDTH_DISPLAY4_WRAPPING_DATACOLUMN_2 = 320;
	private final int WIDTH_DISPLAY4_WRAPPING_DATACOLUMN_3 = 250;
	private final int WIDTH_DISPLAY4_WRAPPING_DATACOLUMN_4 = 150;

	/** Table that holds all the task information */
	private TableView tableView;

	/** Table columns containing different types of task information */
	private TableColumn<Map, String> indexColumn = new TableColumn<>("Index");
	private TableColumn<Map, String> nameColumn = new TableColumn<>("Name");
	private TableColumn<Map, String> timeColumn = new TableColumn<>("Time");
	private TableColumn<Map, String> dateColumn = new TableColumn<>("Date");

	/** Box that holds the table and title of layout */
	private GridPane innerTableBox = new GridPane();
	private HBox outerTableBox = new HBox();

	/**
	 * Constructor for LayoutTemplate
	 * 
	 * @param title					the title for the template when used in the scene
	 * @param list					the ArrayList list to display tasks
	 * @param feedbackList			the ArrayList feedback list to show feedback to user
	 * @param displayDate			the boolean condition to decide if date column should be shown
	 * @param enableExit			the boolean condition to enable escape to go to the
	 * 								previous page
	 */
	public LayoutTemplate(String title, ArrayList<String[]> list, ArrayList<String> feedbackList, boolean displayDate,
			boolean enableExit) {
		if (feedbackList == null) {
			System.out.println("Error: LayoutTemplate null");
		}
		_titleString = title;
		_list = list;
		_listSize = list.size();
		_feedbackList = feedbackList;
		_shouldDisplayDate = displayDate;
		_shouldEnableEscape = enableExit;

		setBottomRegion();
		setTopRegion();
		setCenterRegion();
	}

	/** Set top region to display available shortcuts */
	private void setTopRegion() {
		BoxHeader headerBox = new BoxHeader();
		this.setTop(headerBox);
	}

	/** Set center region to display tasks in table */
	private void setCenterRegion() {
		implementTitle();
		implementTable();
		configureColumns();
		implementInnerTableBox();
		implementOuterTableBox();
		this.setCenter(outerTableBox);
	}

	/** Set bottom region for user input and keypress */
	private void setBottomRegion() {
		Text feedbackText = createFeedbackLabel();
		BoxFeedback feedbackBox = implementFeedbackBox(feedbackText);
		BoxInput inputBox = implementInputBox();
		BorderPane userBox = implementUserBox(feedbackBox, inputBox);

		this.setBottom(userBox);
	}

	/** Create outer box to centralize task table */
	private void implementOuterTableBox() {
		outerTableBox.setAlignment(Pos.CENTER);
		outerTableBox.getChildren().add(innerTableBox);
		outerTableBox.setStyle("-fx-background-color: #182733;");
	}

	/** Create inner box to contain the table view and title of layout */
	private void implementInnerTableBox() {
		innerTableBox.setStyle(STYLE_CENTRE_REGION);
		innerTableBox.setHgrow(tableView, Priority.ALWAYS);
		innerTableBox.add(_titleNode, 0, 0);
		innerTableBox.add(tableView, 0, 1);
	}

	/** Create the table containing the task information */
	private void implementTable() {
		tableView = new TableView<>(populateDataInMap());
		tableView.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);
		tableView.setEditable(false);
		tableView.getSelectionModel().setCellSelectionEnabled(false);

		if (_shouldDisplayDate) {
			tableView.getColumns().setAll(indexColumn, nameColumn, timeColumn, dateColumn);
		} else {
			tableView.getColumns().setAll(indexColumn, nameColumn, timeColumn);
		}

		Callback<TableColumn<Map, String>, TableCell<Map, String>> cellFactoryForMap = (
				TableColumn<Map, String> p) -> new TextFieldTableCell(new StringConverter() {
					@Override
					public String toString(Object t) {
						return t.toString();
					}

					@Override
					public Object fromString(String string) {
						return string;
					}
				});

		indexColumn.setCellFactory(cellFactoryForMap);
		nameColumn.setCellFactory(cellFactoryForMap);
		timeColumn.setCellFactory(cellFactoryForMap);
	}

	/** Configure columns in table to reflect corresponding data */
	private void configureColumns() {
		int indexColWidth = _shouldDisplayDate ? WIDTH_DISPLAY4_WRAPPING_DATACOLUMN_1
				: WIDTH_DISPLAY3_WRAPPING_DATACOLUMN_1;
		int nameColWidth = _shouldDisplayDate ? WIDTH_DISPLAY4_WRAPPING_DATACOLUMN_2
				: WIDTH_DISPLAY3_WRAPPING_DATACOLUMN_2;
		int timeColWidth = _shouldDisplayDate ? WIDTH_DISPLAY4_WRAPPING_DATACOLUMN_3
				: WIDTH_DISPLAY3_WRAPPING_DATACOLUMN_3;

		indexColumn.setCellValueFactory(new MapValueFactory(KEY_COLUMN_INDEX));
		indexColumn.setMinWidth(indexColWidth);
		nameColumn.setCellValueFactory(new MapValueFactory(KEY_COLUMN_NAME));
		nameColumn.setMinWidth(nameColWidth);
		timeColumn.setCellValueFactory(new MapValueFactory(KEY_COLUMN_TIME));
		timeColumn.setMinWidth(timeColWidth);

		if (_shouldDisplayDate) {
			dateColumn.setCellValueFactory(new MapValueFactory(KEY_COLUMN_DATE));
			dateColumn.setMinWidth(WIDTH_DISPLAY4_WRAPPING_DATACOLUMN_4);
		}
	}

	/** Fills up the tableView with all the task information */
	private ObservableList<Map> populateDataInMap() {
		ObservableList<Map> allData = FXCollections.observableArrayList();
		if (_shouldDisplayDate) {
			for (int i = 0; i < _listSize; i++) {
				Map<String, String> dataRow = new HashMap<>();

				String index = _list.get(i)[INDEX_TASK_INDEX];
				String name = _list.get(i)[INDEX_TASK_NAME];
				String time = _list.get(i)[INDEX_TASK_TIME];
				String date = _list.get(i)[INDEX_TASK_DATE];

				dataRow.put(KEY_COLUMN_INDEX, index);
				dataRow.put(KEY_COLUMN_NAME, name);
				dataRow.put(KEY_COLUMN_TIME, time);
				dataRow.put(KEY_COLUMN_DATE, date);

				allData.add(dataRow);
			}
		} else {
			for (int i = 1; i < _listSize; i++) {
				Map<String, String> dataRow = new HashMap<>();

				String index = _list.get(i)[INDEX_TASK_INDEX];
				String name = _list.get(i)[INDEX_TASK_NAME];
				String time = _list.get(i)[INDEX_TASK_TIME];

				dataRow.put(KEY_COLUMN_INDEX, index);
				dataRow.put(KEY_COLUMN_NAME, name);
				dataRow.put(KEY_COLUMN_TIME, time);

				allData.add(dataRow);
			}
		}
		return allData;
	}
	
	/** Implements the title of the layout */
	private void implementTitle() {
		_titleLabel = new Label(_titleString);
		_titleNode = Borders.wrap(_titleLabel).lineBorder().color(Color.AQUAMARINE).build().build();
	}

	/** Implements the user box containing feedback and input field */
	private BorderPane implementUserBox(BoxFeedback feedbackBox, BoxInput inputBox) {
		BorderPane userBox = new BorderPane();
		userBox.setTop(feedbackBox);
		userBox.setBottom(inputBox);
		userBox.setStyle(STYLE_USER_BOX);
		return userBox;
	}

	/** Implements input field for user to key in input and register keypress */
	private BoxInput implementInputBox() {
		BoxInput textField = new BoxInput();
		textField.setOnKeyPressed(new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent ke) {
				if (ke.getCode().equals(KeyCode.UP)) {
					if ((currentScrollIndex + SPEED_SCROLL_UP) >= 0) {
						tableView.scrollTo(currentScrollIndex + SPEED_SCROLL_UP);
						currentScrollIndex = currentScrollIndex + SPEED_SCROLL_UP;
					}
				} else if (ke.getCode().equals(KeyCode.DOWN)) {
					if ((currentScrollIndex + SPEED_SCROLL_DOWN) <= tableView.getItems().size()) {
						tableView.scrollTo(currentScrollIndex + SPEED_SCROLL_DOWN);
						currentScrollIndex = currentScrollIndex + SPEED_SCROLL_DOWN;
					}
				} else if (_shouldEnableEscape && ke.getCode().equals(KeyCode.ESCAPE)) {
					// Displays Category Scene
					Main.setNumToday(Controller.getNumTodayItems());
					Main.setNumTomorrow(Controller.getNumTomorrowItems());
					Main.setNumUpcoming(Controller.getNumUpcomingItems());
					Main.setNumSomeday(Controller.getNumSomedayItems());
					Main.displayCategoryScene();
				}
				Controller.executeKeyPress(textField, ke);
			}
		});
		TextFields.bindAutoCompletion(textField, "add", "delete", "undo", "search", "mark", "edit", "exit");
		return textField;
	}

	/** Implements feedback box for user to see feedback about their commands */
	private BoxFeedback implementFeedbackBox(Text feedbackText) {
		BoxFeedback feedbackBox = new BoxFeedback();
		feedbackBox.getChildren().add(feedbackText);
		return feedbackBox;
	}

	/** Creates label for feedback to display to user */
	private Text createFeedbackLabel() {
		String[] result = _feedbackList.get(0).split(" ", 2);

		String feedbackType = result[0];
		String feedbackMessage = _feedbackList.get(0);
		Text feedbackText = new Text(feedbackMessage);

		feedbackText.setText(feedbackMessage);
		feedbackText.setWrappingWidth(WIDTH_WRAPPING_FEEDBACK);
		feedbackText.setFill(Color.WHITE);
		feedbackText.setFont(Font.font(FONT_FEEDBACK, FONTSIZE_FEEDBACK));

		if (feedbackType.equals("Added")) {
			feedbackText.setFont(Font.font(FONT_FEEDBACK, FontWeight.BOLD, FONTSIZE_FEEDBACK));
		} else if (feedbackType.equals("Edited")) {
			feedbackText.setFont(Font.font(FONT_FEEDBACK, FontPosture.ITALIC, FONTSIZE_FEEDBACK));
		} else if (feedbackType.equals("Marked") || feedbackType.equals("Deleted")) {
			feedbackText.setStrikethrough(true);
			feedbackText.setFill(Color.GREY);
		} else if (feedbackType.equals("Redo")) {
			feedbackText.setUnderline(true);
		} else if (feedbackType.equals("Undo")) {
			feedbackText.setFill(Color.GREY);
		} else if (feedbackType.equals("Clash")) {
			feedbackText.setText(_feedbackList.get(0));
			feedbackText.setFill(Color.CRIMSON);
		}
		return feedbackText;
	}

}
```
###### \userinterface\Main.java
``` java
/**
* The Main class contains the main method to run the entire Clockwork program. Clockwork 
* functions as a scheduler for the user to schedule tasks with only typed commands and 
* keypress.
*/
public class Main extends Application {
	
	/** Application window dimensions */
	private static int WIDTH_WINDOW_DEFAULT = 900;
	private static int HEIGHT_WINDOW_DEFAULT = 600;

	/** Lists containing tasks to display in each scene */
	private static ArrayList<String[]> _todayList = new ArrayList<String[]>();
	private static ArrayList<String[]> _tomorrowList = new ArrayList<String[]>();
	private static ArrayList<String[]> _upcomingList = new ArrayList<String[]>();
	private static ArrayList<String[]> _somedayList = new ArrayList<String[]>();
	private static ArrayList<String[]> _searchList = new ArrayList<String[]>();
	private static ArrayList<String[]> _powerList = new ArrayList<String[]>();
	
	/** Integer containing number of tasks for each category */
	private static int _numToday = 0;
	private static int _numTomorrow = 0;
	private static int _numUpcoming = 0;
	private static int _numSomeday = 0;
	
	/** Layouts used to display tasks in different scenes */
	private static LayoutCategory categoryLayout;
	private static LayoutHelp helpLayout;
	private static LayoutCalendar calendarLayout;
	private static LayoutTemplate todayLayout;
	private static LayoutTemplate tomorrowLayout;
	private static LayoutTemplate upcomingLayout;
	private static LayoutTemplate somedayLayout;
	private static LayoutTemplate searchLayout;
	private static LayoutTemplate allLayout;
	
	/** List to display feedback to user */
	private static ArrayList<String> _feedback;
	
	/** Stage and scene to display to user */
	private static Scene scene;
	private static Stage stage;
	
	public static void main(String[] args) {
		initialiseStorage(args);
		initialiseLogic();
		Application.launch(args);
		
	}
	
	@Override
	public void start(Stage primaryStage) {
		stage = primaryStage;
		setScene();
		setStage();
	}
	
	/** Initialise Scene for GUI */
	private static void setScene(){
		Controller.processEnter("DISPLAY");
	}
	
	/** Initialise Stage for GUI */
	private static void setStage() {
		stage.setTitle("Clockwork");
		stage.setScene(scene);
		stage.sizeToScene();
		stage.setResizable(false);
		stage.getIcons().add(new Image(Main.class
						.getResourceAsStream("icon.png" ))); 
		stage.show();
	}
	
	/** 
	 * Initialise logic package for GUI. Comment out in main(String[] args)
	 * and uncomment UserInterfaceLogicStub method in ClockworkGUIController to test 
	 * GUI with UserInterfaceLogicStub.
	 */
	private static void initialiseLogic() {
		Controller.setLogic(ClockWork.getInstance());
		Controller.resetAllLists();
	}
	
	/** 
	 * Initialise storage paths in logic package.Comment out in main(String[] args) 
	 * and uncomment UserInterfaceLogicStub method in ClockworkGUIController to test 
	 * GUI with UserInterfaceLogicStub.
	 */
	private static void initialiseStorage(String[] args) {
		//Set storage file directory, link with storage file
		ClockWork.setFileDirectory(ClockWork.getStorageFileDirFromSettings());
		// Check if a file directory path is passed in through argument
		if (args.length == 1) {
			// Check if file directory path is valid
			String customFileDirPath = args[0];
			ClockWork.setFileDirectory(StorageUtils.processStorageDirectory(customFileDirPath));
		}
	}
	
	/** Minimises the window */
	protected static void minimise(){
		stage.setIconified(true);
	}
	
	/** Displays the help scene */
	protected static void displayHelpScene(){
		helpLayout = new LayoutHelp();
		scene = new Scene(helpLayout, WIDTH_WINDOW_DEFAULT, HEIGHT_WINDOW_DEFAULT);
		scene.getStylesheets().clear();
		scene.getStylesheets().add(Main.class.getResource("clockwork.css").toExternalForm());
		setStage();
	}
	
	/** Displays the calendar scene */
	protected static void displayCalendarScene(){
		calendarLayout = new LayoutCalendar();
		scene = new Scene(calendarLayout, WIDTH_WINDOW_DEFAULT, HEIGHT_WINDOW_DEFAULT);
		scene.getStylesheets().clear();
		scene.getStylesheets().add(Main.class.getResource("clockwork.css").toExternalForm());
		setStage();
	}
	
	/** Displays the overall category scene */
	protected static void displayCategoryScene(){
		categoryLayout = new LayoutCategory(_numToday, _numTomorrow, _numUpcoming, _numSomeday);
		scene = new Scene(categoryLayout, WIDTH_WINDOW_DEFAULT, HEIGHT_WINDOW_DEFAULT);
		scene.getStylesheets().clear();
		scene.getStylesheets().add(Main.class.getResource("clockwork.css").toExternalForm());
		setStage();
	}
	
	/** Displays the category scene for today */
	protected static void displayTodayScene(){
		_feedback = Controller.getFeedback();
		todayLayout = new LayoutTemplate("Today", _todayList, _feedback, false, true);
		scene = new Scene(todayLayout, WIDTH_WINDOW_DEFAULT, HEIGHT_WINDOW_DEFAULT);
		scene.getStylesheets().clear();
		scene.getStylesheets().add(Main.class.getResource("clockwork.css").toExternalForm());
		setStage();
	}
	
	/** Displays the category scene for tomorrow */
	protected static void displayTomorrowScene(){
		_feedback = Controller.getFeedback();
		tomorrowLayout = new LayoutTemplate("Tomorrow", _tomorrowList, _feedback, false, true);
		scene = new Scene(tomorrowLayout, WIDTH_WINDOW_DEFAULT, HEIGHT_WINDOW_DEFAULT);
		scene.getStylesheets().clear();
		scene.getStylesheets().add(Main.class.getResource("clockwork.css").toExternalForm());
		setStage();
	}
	
	/** Displays the category scene for upcoming tasks not scheduled today or tomorrow but 
	 * with a specified date
	 */
	protected static void displayUpcomingScene(){
		_feedback = Controller.getFeedback();
		upcomingLayout = new LayoutTemplate("Upcoming", _upcomingList,  _feedback, true, true);
		scene = new Scene(upcomingLayout, WIDTH_WINDOW_DEFAULT, HEIGHT_WINDOW_DEFAULT);
		scene.getStylesheets().clear();
		scene.getStylesheets().add(Main.class.getResource("clockwork.css").toExternalForm());
		setStage();
	}
	
	/** Displays the category scene for floating tasks */
	protected static void displaySomedayScene(){
		_feedback = Controller.getFeedback();
		somedayLayout = new LayoutTemplate("Someday", _somedayList,  _feedback, false, true);
		scene = new Scene(somedayLayout, WIDTH_WINDOW_DEFAULT, HEIGHT_WINDOW_DEFAULT);
		scene.getStylesheets().clear();
		scene.getStylesheets().add(Main.class.getResource("clockwork.css").toExternalForm());
		setStage();
	}
	
	/** Displays the search scene */
	protected static void displaySearchScene(){
		_feedback = Controller.getFeedback();
		searchLayout = new LayoutTemplate("Search", _searchList,  _feedback, true, true);
		scene = new Scene(searchLayout, WIDTH_WINDOW_DEFAULT, HEIGHT_WINDOW_DEFAULT);
		scene.getStylesheets().clear();
		scene.getStylesheets().add(Main.class.getResource("clockwork.css").toExternalForm());
		setStage();
	}
	
	/** Displays the all tasks scene */
	protected static void displayAllScene(){
		_feedback = Controller.getFeedback();
		allLayout = new LayoutTemplate("All Tasks", _powerList,  _feedback, true, false);
		scene = new Scene(allLayout, WIDTH_WINDOW_DEFAULT, HEIGHT_WINDOW_DEFAULT);
		scene.getStylesheets().clear();
		scene.getStylesheets().add(Main.class.getResource("clockwork.css").toExternalForm());
		setStage();
	}
	
	/**
	 * Sets list to show feedback to the user based on the input.
	 * 
	 * @param feedback
	 */
	protected static void setFeedbackList(ArrayList<String> feedback){
		_feedback = feedback;
	}
	
	/**
	 * Sets list to show tasks for today. 
	 * 
	 * @param todayList
	 */
	protected static void setTodayList(ArrayList<String[]> todayList){
		_todayList = todayList;
	}
	
	/**
	 * Sets list to show tasks for tomorrow.
	 * 
	 * @param tomorrowList
	 */
	protected static void setTomorrowList(ArrayList<String[]> tomorrowList){
		_tomorrowList = tomorrowList;
	}
	
	/**
	 * Sets list to show tasks not due today or tomorrow, but has a date specified by user.
	 * 
	 * @param upcomingList
	 */
	protected static void setUpcomingList(ArrayList<String[]> upcomingList){
		_upcomingList = upcomingList;
	}
	
	/**
	 * Sets list to show floating tasks that does not have a date specified by user.
	 * 
	 * @param somedayList
	 */
	protected static void setSomedayList(ArrayList<String[]> somedayList){
		_somedayList = somedayList;
	}
	
	/**
	 * Sets list to show all tasks with the date specified.
	 * 
	 * @param powerList
	 */
	protected static void setPowerList(ArrayList<String[]> powerList){
		_powerList = powerList;
	}
	
	/**
	 * Sets list to show tasks the user is searching for.
	 * 
	 * @param searchList
	 */
	protected static void setSearchList(ArrayList<String[]> searchList) {
		_searchList = searchList;
	}
	
	/**
	 * Sets the number of items to display for the list for today.
	 * 
	 * @param numToday
	 */
	protected static void setNumToday(int numToday){
		_numToday = numToday;
	}
	
	/**
	 * Sets the number of items to display for the list for tomorrow.
	 * 
	 * @param numTomorrow
	 */
	protected static void setNumTomorrow(int numTomorrow){
		_numTomorrow = numTomorrow;
	}
	
	/**
	 * Sets the number of items to display for the list for upcoming tasks.
	 * 
	 * @param numUpcoming
	 */
	protected static void setNumUpcoming(int numUpcoming){
		_numUpcoming = numUpcoming;
	}
	
	/**
	 * Sets the number of items to display for the list for floating tasks.
	 * 
	 * @param numSomeday
	 */
	protected static void setNumSomeday(int numSomeday){
		_numSomeday = numSomeday;
	}
}
```
###### \userinterface\UserInterfaceStub.java
``` java
/**
* The UserInterfaceStub class is used in place of the Logic and Storage component and is mostly 
* used while testing the GUI to check if the correct information is displayed on GUI.
*/
public class UserInterfaceStub {
	/** Populates the task with placeholder task information */
	public static ArrayList<String[]> populateList(ArrayList<String[]> taskList){
		taskList.clear();
		
		String[] indivTask = new String[4];
		
		indivTask[0] = "1.";
		indivTask[1] = "Running with Felicia";
		indivTask[2] = "17:00 - 19:00";
		indivTask[3] = "7 Apr 2016";
		
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		taskList.add(indivTask);
		
		return taskList;
	}
	
	/** Populates the feedback list with placeholder text and type */
	public static ArrayList<String> populateFeedbackList(){
		ArrayList<String> feedbackList = new ArrayList<String>();
		feedbackList.add("Added");
		feedbackList.add("Added Run with Felicia");
		return feedbackList;
	}
}
```
